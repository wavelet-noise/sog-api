<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sands of Glory: tiny_utf8::basic_string&lt; ValueType, DataType, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Sands of Glory<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtiny__utf8_1_1basic__string.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtiny__utf8_1_1basic__string-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tiny_utf8::basic_string&lt; ValueType, DataType, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for tiny_utf8::basic_string&lt; ValueType, DataType, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtiny__utf8_1_1basic__string.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtiny__utf8_1_1basic__string_1_1_n_o_n___s_s_o.html">NON_SSO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layout specifications.  <a href="structtiny__utf8_1_1basic__string_1_1_n_o_n___s_s_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtiny__utf8_1_1basic__string_1_1_s_s_o.html">SSO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aae05d78f88675d9150035e54458ff431"><td class="memItemLeft" align="right" valign="top"><a id="aae05d78f88675d9150035e54458ff431" name="aae05d78f88675d9150035e54458ff431"></a>enum &#160;</td><td class="memItemRight" valign="bottom">: size_type { <b>npos</b> = (size_type)-1
 }</td></tr>
<tr class="separator:aae05d78f88675d9150035e54458ff431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27761b2014a3aab11240095a3ea9baca"><td class="memItemLeft" align="right" valign="top"><a id="a27761b2014a3aab11240095a3ea9baca" name="a27761b2014a3aab11240095a3ea9baca"></a>
typedef DataType&#160;</td><td class="memItemRight" valign="bottom"><b>data_type</b></td></tr>
<tr class="separator:a27761b2014a3aab11240095a3ea9baca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0f964c5a3aaf48e7f3c53fdc7fc614"><td class="memItemLeft" align="right" valign="top"><a id="a6b0f964c5a3aaf48e7f3c53fdc7fc614" name="a6b0f964c5a3aaf48e7f3c53fdc7fc614"></a>
typedef std::allocator_traits&lt; Allocator &gt;::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a6b0f964c5a3aaf48e7f3c53fdc7fc614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92130583bc7916a84d6e9db3755a4556"><td class="memItemLeft" align="right" valign="top"><a id="a92130583bc7916a84d6e9db3755a4556" name="a92130583bc7916a84d6e9db3755a4556"></a>
typedef std::allocator_traits&lt; Allocator &gt;::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a92130583bc7916a84d6e9db3755a4556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62faa866b16a680565c5f06a7fec18b8"><td class="memItemLeft" align="right" valign="top"><a id="a62faa866b16a680565c5f06a7fec18b8" name="a62faa866b16a680565c5f06a7fec18b8"></a>
typedef ValueType&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a62faa866b16a680565c5f06a7fec18b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1c297a210329cf70bd2d566c5cb4cf"><td class="memItemLeft" align="right" valign="top"><a id="abf1c297a210329cf70bd2d566c5cb4cf" name="abf1c297a210329cf70bd2d566c5cb4cf"></a>
typedef <a class="el" href="structtiny__utf8_1_1codepoint__reference.html">codepoint_reference</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:abf1c297a210329cf70bd2d566c5cb4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0696b0cff896f762b83ff0db2202a38"><td class="memItemLeft" align="right" valign="top"><a id="ab0696b0cff896f762b83ff0db2202a38" name="ab0696b0cff896f762b83ff0db2202a38"></a>
typedef <a class="el" href="structtiny__utf8_1_1codepoint__reference.html">codepoint_reference</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>checked_reference</b></td></tr>
<tr class="separator:ab0696b0cff896f762b83ff0db2202a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347bb1c624122fd4d5fdc0587ad60b51"><td class="memItemLeft" align="right" valign="top"><a id="a347bb1c624122fd4d5fdc0587ad60b51" name="a347bb1c624122fd4d5fdc0587ad60b51"></a>
typedef <a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_codepoint_reference</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>raw_reference</b></td></tr>
<tr class="separator:a347bb1c624122fd4d5fdc0587ad60b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b39543e01c033d417c3e6f3a9e5a4"><td class="memItemLeft" align="right" valign="top"><a id="a078b39543e01c033d417c3e6f3a9e5a4" name="a078b39543e01c033d417c3e6f3a9e5a4"></a>
typedef <a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_codepoint_reference</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>raw_checked_reference</b></td></tr>
<tr class="separator:a078b39543e01c033d417c3e6f3a9e5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ac219b348637d3319805c9f094b07a"><td class="memItemLeft" align="right" valign="top"><a id="ae0ac219b348637d3319805c9f094b07a" name="ae0ac219b348637d3319805c9f094b07a"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:ae0ac219b348637d3319805c9f094b07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab613dff7c90bf28833faaa9cd615cabd"><td class="memItemLeft" align="right" valign="top"><a id="ab613dff7c90bf28833faaa9cd615cabd" name="ab613dff7c90bf28833faaa9cd615cabd"></a>
typedef std::uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><b>width_type</b></td></tr>
<tr class="separator:ab613dff7c90bf28833faaa9cd615cabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cfdedec8fd05d3af838a4d9634077f"><td class="memItemLeft" align="right" valign="top"><a id="af4cfdedec8fd05d3af838a4d9634077f" name="af4cfdedec8fd05d3af838a4d9634077f"></a>
typedef <a class="el" href="structtiny__utf8_1_1iterator.html">tiny_utf8::iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:af4cfdedec8fd05d3af838a4d9634077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d97d62e92b95941c80e55f4fa01e71a"><td class="memItemLeft" align="right" valign="top"><a id="a5d97d62e92b95941c80e55f4fa01e71a" name="a5d97d62e92b95941c80e55f4fa01e71a"></a>
typedef <a class="el" href="structtiny__utf8_1_1const__iterator.html">tiny_utf8::const_iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a5d97d62e92b95941c80e55f4fa01e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c738f30df27039b17ca841065dd1e86"><td class="memItemLeft" align="right" valign="top"><a id="a5c738f30df27039b17ca841065dd1e86" name="a5c738f30df27039b17ca841065dd1e86"></a>
typedef <a class="el" href="structtiny__utf8_1_1reverse__iterator.html">tiny_utf8::reverse_iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a5c738f30df27039b17ca841065dd1e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7a3691342c3230de74d41120a02160"><td class="memItemLeft" align="right" valign="top"><a id="a4b7a3691342c3230de74d41120a02160" name="a4b7a3691342c3230de74d41120a02160"></a>
typedef <a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">tiny_utf8::const_reverse_iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a4b7a3691342c3230de74d41120a02160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e7c6444cb5dc651eddf42084e0574f"><td class="memItemLeft" align="right" valign="top"><a id="a44e7c6444cb5dc651eddf42084e0574f" name="a44e7c6444cb5dc651eddf42084e0574f"></a>
typedef <a class="el" href="structtiny__utf8_1_1iterator.html">tiny_utf8::iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>raw_iterator</b></td></tr>
<tr class="separator:a44e7c6444cb5dc651eddf42084e0574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde2bbdca4bb4be87a72e035d4b3cb41"><td class="memItemLeft" align="right" valign="top"><a id="adde2bbdca4bb4be87a72e035d4b3cb41" name="adde2bbdca4bb4be87a72e035d4b3cb41"></a>
typedef <a class="el" href="structtiny__utf8_1_1const__iterator.html">tiny_utf8::const_iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>raw_const_iterator</b></td></tr>
<tr class="separator:adde2bbdca4bb4be87a72e035d4b3cb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7ecaaf1eff8208b802dc993cee0bec"><td class="memItemLeft" align="right" valign="top"><a id="a1d7ecaaf1eff8208b802dc993cee0bec" name="a1d7ecaaf1eff8208b802dc993cee0bec"></a>
typedef <a class="el" href="structtiny__utf8_1_1reverse__iterator.html">tiny_utf8::reverse_iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>raw_reverse_iterator</b></td></tr>
<tr class="separator:a1d7ecaaf1eff8208b802dc993cee0bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc86b008bd7c3b3185863ed4434a08c"><td class="memItemLeft" align="right" valign="top"><a id="a4dc86b008bd7c3b3185863ed4434a08c" name="a4dc86b008bd7c3b3185863ed4434a08c"></a>
typedef <a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">tiny_utf8::const_reverse_iterator</a>&lt; <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>raw_const_reverse_iterator</b></td></tr>
<tr class="separator:a4dc86b008bd7c3b3185863ed4434a08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c555083a026c43c36decd1fd544b29"><td class="memItemLeft" align="right" valign="top"><a id="aa4c555083a026c43c36decd1fd544b29" name="aa4c555083a026c43c36decd1fd544b29"></a>
typedef Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:aa4c555083a026c43c36decd1fd544b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e230226f40226f2386cb43814353f9"><td class="memItemLeft" align="right" valign="top"><a id="a16e230226f40226f2386cb43814353f9" name="a16e230226f40226f2386cb43814353f9"></a>
typedef size_type&#160;</td><td class="memItemRight" valign="bottom"><b>indicator_type</b></td></tr>
<tr class="separator:a16e230226f40226f2386cb43814353f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab338206fe59efb7b1aeb577bb8586cf9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ab338206fe59efb7b1aeb577bb8586cf9">basic_string</a> () noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_default_constructible&lt; Allocator &gt;())</td></tr>
<tr class="separator:ab338206fe59efb7b1aeb577bb8586cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7e5324bc1ad45530098ab3447404b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#afe7e5324bc1ad45530098ab3447404b2">basic_string</a> (const allocator_type &amp;alloc) noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_copy_constructible&lt; Allocator &gt;())</td></tr>
<tr class="separator:afe7e5324bc1ad45530098ab3447404b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065b100aa8861f0c24ad46bfaad7c119"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a065b100aa8861f0c24ad46bfaad7c119"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a065b100aa8861f0c24ad46bfaad7c119">basic_string</a> (T &amp;&amp;str, const allocator_type &amp;alloc=allocator_type(), enable_if_ptr&lt; T, data_type &gt; *={}) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a065b100aa8861f0c24ad46bfaad7c119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575d024d10dbd30774dad39667b8b15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a2575d024d10dbd30774dad39667b8b15">basic_string</a> (const data_type *str, size_type len, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a2575d024d10dbd30774dad39667b8b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab065cce333f0ceedbdd69dc3e69c3ca3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ab065cce333f0ceedbdd69dc3e69c3ca3">basic_string</a> (const data_type *str, size_type pos, size_type len, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ab065cce333f0ceedbdd69dc3e69c3ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4ce46ecb8d0f86098cb9c18ecef656"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:aaa4ce46ecb8d0f86098cb9c18ecef656"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aaa4ce46ecb8d0f86098cb9c18ecef656">basic_string</a> (const data_type(&amp;str)[LITLEN], const allocator_type &amp;alloc=allocator_type(), <a class="el" href="classtiny__utf8_1_1basic__string.html#a2cca7472f3dd133d83232afcd17a9f27">enable_if_small_string</a>&lt; LITLEN &gt;={}) noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_copy_constructible&lt; Allocator &gt;())</td></tr>
<tr class="separator:aaa4ce46ecb8d0f86098cb9c18ecef656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d0597ce5967edbb7af054af82f39a2"><td class="memTemplParams" colspan="2"><a id="ae4d0597ce5967edbb7af054af82f39a2" name="ae4d0597ce5967edbb7af054af82f39a2"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:ae4d0597ce5967edbb7af054af82f39a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_string</b> (const data_type(&amp;str)[LITLEN], const allocator_type &amp;alloc=allocator_type(), enable_if_not_small_string&lt; LITLEN &gt;={}) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ae4d0597ce5967edbb7af054af82f39a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc6ce18e0aa93e7821fe8771b2c8874"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:aecc6ce18e0aa93e7821fe8771b2c8874"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aecc6ce18e0aa93e7821fe8771b2c8874">basic_string</a> (const data_type(&amp;str)[LITLEN], size_type len, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aecc6ce18e0aa93e7821fe8771b2c8874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201c79ff44c60bb093c76b8a6bab827"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:ac201c79ff44c60bb093c76b8a6bab827"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac201c79ff44c60bb093c76b8a6bab827">basic_string</a> (const data_type(&amp;str)[LITLEN], size_type pos, size_type len, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ac201c79ff44c60bb093c76b8a6bab827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d82a8d454ad5306dd6659392329ce9"><td class="memTemplParams" colspan="2">template&lt;typename C , typename A &gt; </td></tr>
<tr class="memitem:a03d82a8d454ad5306dd6659392329ce9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a03d82a8d454ad5306dd6659392329ce9">basic_string</a> (std::basic_string&lt; data_type, C, A &gt; str, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a03d82a8d454ad5306dd6659392329ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f31a2cac7ab8f46b3e5f69fe6e0bdd"><td class="memTemplParams" colspan="2">template&lt;typename C , typename A &gt; </td></tr>
<tr class="memitem:a83f31a2cac7ab8f46b3e5f69fe6e0bdd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a83f31a2cac7ab8f46b3e5f69fe6e0bdd">basic_string</a> (std::basic_string&lt; data_type, C, A &gt; str, size_type len, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a83f31a2cac7ab8f46b3e5f69fe6e0bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f04076f2b6bcad196d3ac012b971911"><td class="memTemplParams" colspan="2"><a id="a9f04076f2b6bcad196d3ac012b971911" name="a9f04076f2b6bcad196d3ac012b971911"></a>
template&lt;typename C , typename A &gt; </td></tr>
<tr class="memitem:a9f04076f2b6bcad196d3ac012b971911"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_string</b> (std::basic_string&lt; data_type, C, A &gt; str, size_type pos, size_type len, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a9f04076f2b6bcad196d3ac012b971911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f26be2b043990c8c73be8ed12139cda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a4f26be2b043990c8c73be8ed12139cda">basic_string</a> (size_type n, value_type cp, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a4f26be2b043990c8c73be8ed12139cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5efb35075738c63e08dd9739f3bbe1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aa5efb35075738c63e08dd9739f3bbe1e">basic_string</a> (size_type n, data_type cp, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aa5efb35075738c63e08dd9739f3bbe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e044d8a99b592669c9876b3cd0c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac91e044d8a99b592669c9876b3cd0c96">basic_string</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str, size_type pos, size_type count=basic_string::npos, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ac91e044d8a99b592669c9876b3cd0c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255363c4d2a4dbaddde22855b47829cc"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a255363c4d2a4dbaddde22855b47829cc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a255363c4d2a4dbaddde22855b47829cc">basic_string</a> (InputIt first, InputIt last, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a255363c4d2a4dbaddde22855b47829cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ba0ad060e28bd0bce5a83010665626"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aa3ba0ad060e28bd0bce5a83010665626">basic_string</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aa3ba0ad060e28bd0bce5a83010665626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7d57ebc545f5fa3e86eadb67eb799"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ad6e7d57ebc545f5fa3e86eadb67eb799">basic_string</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str, const allocator_type &amp;alloc) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ad6e7d57ebc545f5fa3e86eadb67eb799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847816999b619f749e4e5f95f33d383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac847816999b619f749e4e5f95f33d383">basic_string</a> (const value_type *str, size_type len, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ac847816999b619f749e4e5f95f33d383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb1160f16024ea3c111e669424b3d6f"><td class="memTemplParams" colspan="2"><a id="a2cb1160f16024ea3c111e669424b3d6f" name="a2cb1160f16024ea3c111e669424b3d6f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cb1160f16024ea3c111e669424b3d6f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_string</b> (T &amp;&amp;str, const allocator_type &amp;alloc=allocator_type(), enable_if_ptr&lt; T, value_type &gt; *={}) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a2cb1160f16024ea3c111e669424b3d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccbfe16fefc848e4976e3b2693d482e"><td class="memTemplParams" colspan="2"><a id="a3ccbfe16fefc848e4976e3b2693d482e" name="a3ccbfe16fefc848e4976e3b2693d482e"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a3ccbfe16fefc848e4976e3b2693d482e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_string</b> (const value_type(&amp;str)[LITLEN], const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a3ccbfe16fefc848e4976e3b2693d482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549605139f453e093c6a03533f3304ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a549605139f453e093c6a03533f3304ed">basic_string</a> (std::initializer_list&lt; value_type &gt; ilist, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a549605139f453e093c6a03533f3304ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ef4f2bd71cdd4c4c1d74747b99e519"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a06ef4f2bd71cdd4c4c1d74747b99e519">basic_string</a> (value_type cp, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a06ef4f2bd71cdd4c4c1d74747b99e519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9bf577943a8f9fab5414c1cd99e94e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a7c9bf577943a8f9fab5414c1cd99e94e">basic_string</a> (data_type ch, const allocator_type &amp;alloc=allocator_type()) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a7c9bf577943a8f9fab5414c1cd99e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8928cc6556795908e48cbd7c0f4b73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a0f8928cc6556795908e48cbd7c0f4b73">basic_string</a> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&amp;str) noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_move_constructible&lt; Allocator &gt;())</td></tr>
<tr class="separator:a0f8928cc6556795908e48cbd7c0f4b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb828ec4b048102a9a78412996b9e84c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aeb828ec4b048102a9a78412996b9e84c">basic_string</a> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&amp;str, const allocator_type &amp;alloc) noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_copy_constructible&lt; Allocator &gt;())</td></tr>
<tr class="separator:aeb828ec4b048102a9a78412996b9e84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4218f2887c7a67397f57bc4856b320"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a7d4218f2887c7a67397f57bc4856b320">~basic_string</a> () noexcept</td></tr>
<tr class="separator:a7d4218f2887c7a67397f57bc4856b320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba1bb0ebaf862bbee1cdfa9a7924328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aeba1bb0ebaf862bbee1cdfa9a7924328">operator=</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aeba1bb0ebaf862bbee1cdfa9a7924328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c3d64ab683835a700ed331d624278c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a66c3d64ab683835a700ed331d624278c">operator=</a> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&amp;str) noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_move_assignable&lt; Allocator &gt;())</td></tr>
<tr class="separator:a66c3d64ab683835a700ed331d624278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b833384a9a89159c5276d79e10f5af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a3b833384a9a89159c5276d79e10f5af4">clear</a> () noexcept</td></tr>
<tr class="separator:a3b833384a9a89159c5276d79e10f5af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f0ebf7b5d4b1100f037a9cabf8f7d7"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a51f0ebf7b5d4b1100f037a9cabf8f7d7">get_allocator</a> () const noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_copy_constructible&lt; Allocator &gt;())</td></tr>
<tr class="separator:a51f0ebf7b5d4b1100f037a9cabf8f7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d77ab002b3c11a55dfc1ea95e7ec28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a2d77ab002b3c11a55dfc1ea95e7ec28c">shrink_to_fit</a> () noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a2d77ab002b3c11a55dfc1ea95e7ec28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a34205d5cf0796596b28c35390c51f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a69a34205d5cf0796596b28c35390c51f">swap</a> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_move_assignable&lt; Allocator &gt;())</td></tr>
<tr class="separator:a69a34205d5cf0796596b28c35390c51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b8082304775f237b50da66aaeb84e1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ae2b8082304775f237b50da66aaeb84e1">capacity</a> () const noexcept</td></tr>
<tr class="separator:ae2b8082304775f237b50da66aaeb84e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec8397bb2afb04f6549f53fcd2c62bd"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#afec8397bb2afb04f6549f53fcd2c62bd">at</a> (size_type n) const noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:afec8397bb2afb04f6549f53fcd2c62bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857ab26143d09206256f8a3a71daa61"><td class="memItemLeft" align="right" valign="top"><a id="a4857ab26143d09206256f8a3a71daa61" name="a4857ab26143d09206256f8a3a71daa61"></a>
value_type&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type n, std::nothrow_t) const noexcept</td></tr>
<tr class="separator:a4857ab26143d09206256f8a3a71daa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9f7e80820bcfce3cb880eedecfba3"><td class="memItemLeft" align="right" valign="top"><a id="a7fd9f7e80820bcfce3cb880eedecfba3" name="a7fd9f7e80820bcfce3cb880eedecfba3"></a>
<a class="el" href="structtiny__utf8_1_1codepoint__reference.html">checked_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type n) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a7fd9f7e80820bcfce3cb880eedecfba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12ebed2167fc2d158e1e21a8a62d441"><td class="memItemLeft" align="right" valign="top"><a id="af12ebed2167fc2d158e1e21a8a62d441" name="af12ebed2167fc2d158e1e21a8a62d441"></a>
<a class="el" href="structtiny__utf8_1_1codepoint__reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (size_type n, std::nothrow_t) noexcept</td></tr>
<tr class="separator:af12ebed2167fc2d158e1e21a8a62d441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72370d5b61daf6152e4c53fb4c83afee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_checked_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a72370d5b61daf6152e4c53fb4c83afee">raw_at</a> (size_type byte_index) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a72370d5b61daf6152e4c53fb4c83afee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab898c13c6ae21a8a40698cd55376ee42"><td class="memItemLeft" align="right" valign="top"><a id="ab898c13c6ae21a8a40698cd55376ee42" name="ab898c13c6ae21a8a40698cd55376ee42"></a>
<a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_at</b> (size_type byte_index, std::nothrow_t) noexcept</td></tr>
<tr class="separator:ab898c13c6ae21a8a40698cd55376ee42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec27305d15ca517a5ec3c60580cb5e"><td class="memItemLeft" align="right" valign="top"><a id="ac4ec27305d15ca517a5ec3c60580cb5e" name="ac4ec27305d15ca517a5ec3c60580cb5e"></a>
value_type&#160;</td><td class="memItemRight" valign="bottom"><b>raw_at</b> (size_type byte_index) const noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ac4ec27305d15ca517a5ec3c60580cb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff4e6f62b12638a8cef893b9d107b1c"><td class="memItemLeft" align="right" valign="top"><a id="aeff4e6f62b12638a8cef893b9d107b1c" name="aeff4e6f62b12638a8cef893b9d107b1c"></a>
value_type&#160;</td><td class="memItemRight" valign="bottom"><b>raw_at</b> (size_type byte_index, std::nothrow_t) const noexcept</td></tr>
<tr class="separator:aeff4e6f62b12638a8cef893b9d107b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d2bbad98237f56f838f70399c725ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac9d2bbad98237f56f838f70399c725ad">get</a> (size_type n) noexcept</td></tr>
<tr class="separator:ac9d2bbad98237f56f838f70399c725ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec237647638f3a4d53d2d6477a985ae"><td class="memItemLeft" align="right" valign="top"><a id="adec237647638f3a4d53d2d6477a985ae" name="adec237647638f3a4d53d2d6477a985ae"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (size_type n) const noexcept</td></tr>
<tr class="separator:adec237647638f3a4d53d2d6477a985ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef267fb9bcfa437525b3e49c9777d381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aef267fb9bcfa437525b3e49c9777d381">raw_get</a> (size_type n) noexcept</td></tr>
<tr class="separator:aef267fb9bcfa437525b3e49c9777d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaeecabaefc3b36e762ff8db12ae86f"><td class="memItemLeft" align="right" valign="top"><a id="a5aaeecabaefc3b36e762ff8db12ae86f" name="a5aaeecabaefc3b36e762ff8db12ae86f"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">raw_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_get</b> (size_type n) const noexcept</td></tr>
<tr class="separator:a5aaeecabaefc3b36e762ff8db12ae86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1487717f4c6be386e37a6378250f8480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a1487717f4c6be386e37a6378250f8480">rget</a> (size_type n) noexcept</td></tr>
<tr class="separator:a1487717f4c6be386e37a6378250f8480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341f5ec2c7b26cc1ab5093b3c205f5fe"><td class="memItemLeft" align="right" valign="top"><a id="a341f5ec2c7b26cc1ab5093b3c205f5fe" name="a341f5ec2c7b26cc1ab5093b3c205f5fe"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rget</b> (size_type n) const noexcept</td></tr>
<tr class="separator:a341f5ec2c7b26cc1ab5093b3c205f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e81d23dd90dfa7d4c0d4bf1b6458fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">raw_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ad2e81d23dd90dfa7d4c0d4bf1b6458fa">raw_rget</a> (size_type n) noexcept</td></tr>
<tr class="separator:ad2e81d23dd90dfa7d4c0d4bf1b6458fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980eb93eeda26d9bbb700e1e446bc338"><td class="memItemLeft" align="right" valign="top"><a id="a980eb93eeda26d9bbb700e1e446bc338" name="a980eb93eeda26d9bbb700e1e446bc338"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">raw_const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_rget</b> (size_type n) const noexcept</td></tr>
<tr class="separator:a980eb93eeda26d9bbb700e1e446bc338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f204a4cbed37680fd8489fd48006d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1codepoint__reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a59f204a4cbed37680fd8489fd48006d2">operator[]</a> (size_type n) noexcept</td></tr>
<tr class="separator:a59f204a4cbed37680fd8489fd48006d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b04f50184ef24c509724b8e69a705d"><td class="memItemLeft" align="right" valign="top"><a id="a55b04f50184ef24c509724b8e69a705d" name="a55b04f50184ef24c509724b8e69a705d"></a>
value_type&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_type n) const noexcept</td></tr>
<tr class="separator:a55b04f50184ef24c509724b8e69a705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5310b60c21d2a253d575b8825c73b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#abe5310b60c21d2a253d575b8825c73b2">operator()</a> (size_type n) noexcept</td></tr>
<tr class="separator:abe5310b60c21d2a253d575b8825c73b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983f32dc7adbc2993a27077e33fa9cb5"><td class="memItemLeft" align="right" valign="top"><a id="a983f32dc7adbc2993a27077e33fa9cb5" name="a983f32dc7adbc2993a27077e33fa9cb5"></a>
value_type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_type n) const noexcept</td></tr>
<tr class="separator:a983f32dc7adbc2993a27077e33fa9cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131f60eb7a33b62bf407a07d043dffe6"><td class="memItemLeft" align="right" valign="top">const data_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a131f60eb7a33b62bf407a07d043dffe6">c_str</a> () const noexcept</td></tr>
<tr class="separator:a131f60eb7a33b62bf407a07d043dffe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01d68f238c184f7f61dbeab64db4766"><td class="memItemLeft" align="right" valign="top"><a id="ab01d68f238c184f7f61dbeab64db4766" name="ab01d68f238c184f7f61dbeab64db4766"></a>
const data_type *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const noexcept</td></tr>
<tr class="separator:ab01d68f238c184f7f61dbeab64db4766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93af548be67b7f1fd2c4e40f5264e607"><td class="memItemLeft" align="right" valign="top"><a id="a93af548be67b7f1fd2c4e40f5264e607" name="a93af548be67b7f1fd2c4e40f5264e607"></a>
data_type *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () noexcept</td></tr>
<tr class="separator:a93af548be67b7f1fd2c4e40f5264e607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbad7e5e7fad26c31b37828ab5098a1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a4cbad7e5e7fad26c31b37828ab5098a1">length</a> () const noexcept</td></tr>
<tr class="separator:a4cbad7e5e7fad26c31b37828ab5098a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1388350a2d5983f12dccd793353d60d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#af1388350a2d5983f12dccd793353d60d">size</a> () const noexcept</td></tr>
<tr class="separator:af1388350a2d5983f12dccd793353d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba7f5013741d835e165f7cec7bb46ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a3ba7f5013741d835e165f7cec7bb46ba">empty</a> () const noexcept</td></tr>
<tr class="separator:a3ba7f5013741d835e165f7cec7bb46ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18db48fef0ee0129a37111302961900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aa18db48fef0ee0129a37111302961900">begin</a> () noexcept</td></tr>
<tr class="separator:aa18db48fef0ee0129a37111302961900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fe1e9407f5a454150dc57f8fe1f468"><td class="memItemLeft" align="right" valign="top"><a id="a16fe1e9407f5a454150dc57f8fe1f468" name="a16fe1e9407f5a454150dc57f8fe1f468"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a16fe1e9407f5a454150dc57f8fe1f468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dee10990d28438968238867c4e50b4"><td class="memItemLeft" align="right" valign="top"><a id="a61dee10990d28438968238867c4e50b4" name="a61dee10990d28438968238867c4e50b4"></a>
<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_begin</b> () noexcept</td></tr>
<tr class="separator:a61dee10990d28438968238867c4e50b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee7919e2e86803e557991c41eed0b63"><td class="memItemLeft" align="right" valign="top"><a id="a8ee7919e2e86803e557991c41eed0b63" name="a8ee7919e2e86803e557991c41eed0b63"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">raw_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_begin</b> () const noexcept</td></tr>
<tr class="separator:a8ee7919e2e86803e557991c41eed0b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a514aaf5155df60add7878081063f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac9a514aaf5155df60add7878081063f6">end</a> () noexcept</td></tr>
<tr class="separator:ac9a514aaf5155df60add7878081063f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a41d2cbff681fb29dc995965815088"><td class="memItemLeft" align="right" valign="top"><a id="ae7a41d2cbff681fb29dc995965815088" name="ae7a41d2cbff681fb29dc995965815088"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:ae7a41d2cbff681fb29dc995965815088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc786acaa075e05201ca5c0ba52c6cfd"><td class="memItemLeft" align="right" valign="top"><a id="abc786acaa075e05201ca5c0ba52c6cfd" name="abc786acaa075e05201ca5c0ba52c6cfd"></a>
<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_end</b> () noexcept</td></tr>
<tr class="separator:abc786acaa075e05201ca5c0ba52c6cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0109c8820948d6f6385665317a1ffda4"><td class="memItemLeft" align="right" valign="top"><a id="a0109c8820948d6f6385665317a1ffda4" name="a0109c8820948d6f6385665317a1ffda4"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">raw_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_end</b> () const noexcept</td></tr>
<tr class="separator:a0109c8820948d6f6385665317a1ffda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12602f878e2feeb4c9592cc5f35bd6b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a12602f878e2feeb4c9592cc5f35bd6b6">rbegin</a> () noexcept</td></tr>
<tr class="separator:a12602f878e2feeb4c9592cc5f35bd6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b829f56c07ec611dfc1b88f0306f6a"><td class="memItemLeft" align="right" valign="top"><a id="a18b829f56c07ec611dfc1b88f0306f6a" name="a18b829f56c07ec611dfc1b88f0306f6a"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const noexcept</td></tr>
<tr class="separator:a18b829f56c07ec611dfc1b88f0306f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ab6539b5a8dc5f312a415355662045"><td class="memItemLeft" align="right" valign="top"><a id="a73ab6539b5a8dc5f312a415355662045" name="a73ab6539b5a8dc5f312a415355662045"></a>
<a class="el" href="structtiny__utf8_1_1reverse__iterator.html">raw_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_rbegin</b> () noexcept</td></tr>
<tr class="separator:a73ab6539b5a8dc5f312a415355662045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea9ed7b89b5323b0c764fe5adbcf900"><td class="memItemLeft" align="right" valign="top"><a id="a3ea9ed7b89b5323b0c764fe5adbcf900" name="a3ea9ed7b89b5323b0c764fe5adbcf900"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">raw_const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_rbegin</b> () const noexcept</td></tr>
<tr class="separator:a3ea9ed7b89b5323b0c764fe5adbcf900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bc15a180a4c3028bad7ce9844c41ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ad6bc15a180a4c3028bad7ce9844c41ca">rend</a> () noexcept</td></tr>
<tr class="separator:ad6bc15a180a4c3028bad7ce9844c41ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaab0ff5e2291d59c5f835e4eb477250"><td class="memItemLeft" align="right" valign="top"><a id="acaab0ff5e2291d59c5f835e4eb477250" name="acaab0ff5e2291d59c5f835e4eb477250"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const noexcept</td></tr>
<tr class="separator:acaab0ff5e2291d59c5f835e4eb477250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be8bc56d9128ece971cdf55fa9e84a1"><td class="memItemLeft" align="right" valign="top"><a id="a8be8bc56d9128ece971cdf55fa9e84a1" name="a8be8bc56d9128ece971cdf55fa9e84a1"></a>
<a class="el" href="structtiny__utf8_1_1reverse__iterator.html">raw_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_rend</b> () noexcept</td></tr>
<tr class="separator:a8be8bc56d9128ece971cdf55fa9e84a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7929312293e8703132cb6657756ce579"><td class="memItemLeft" align="right" valign="top"><a id="a7929312293e8703132cb6657756ce579" name="a7929312293e8703132cb6657756ce579"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">raw_const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_rend</b> () const noexcept</td></tr>
<tr class="separator:a7929312293e8703132cb6657756ce579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95be3c884b6d0a33d3a486f3027f23bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a95be3c884b6d0a33d3a486f3027f23bc">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a95be3c884b6d0a33d3a486f3027f23bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9c18dab41cb2bc8f21ee945f4b1303"><td class="memItemLeft" align="right" valign="top"><a id="aac9c18dab41cb2bc8f21ee945f4b1303" name="aac9c18dab41cb2bc8f21ee945f4b1303"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">raw_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_cbegin</b> () const noexcept</td></tr>
<tr class="separator:aac9c18dab41cb2bc8f21ee945f4b1303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c333b1abff8337425b7f0cce46f52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a04c333b1abff8337425b7f0cce46f52d">cend</a> () const noexcept</td></tr>
<tr class="separator:a04c333b1abff8337425b7f0cce46f52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72ef2be6583a4dc69977c01f272c678"><td class="memItemLeft" align="right" valign="top"><a id="af72ef2be6583a4dc69977c01f272c678" name="af72ef2be6583a4dc69977c01f272c678"></a>
<a class="el" href="structtiny__utf8_1_1const__iterator.html">raw_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_cend</b> () const noexcept</td></tr>
<tr class="separator:af72ef2be6583a4dc69977c01f272c678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33be9b59b9ce309e2471f9425350d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ad33be9b59b9ce309e2471f9425350d3e">crbegin</a> () const noexcept</td></tr>
<tr class="separator:ad33be9b59b9ce309e2471f9425350d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea09e4af21530ae98e405983afd914e"><td class="memItemLeft" align="right" valign="top"><a id="a2ea09e4af21530ae98e405983afd914e" name="a2ea09e4af21530ae98e405983afd914e"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">raw_const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_crbegin</b> () const noexcept</td></tr>
<tr class="separator:a2ea09e4af21530ae98e405983afd914e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4902651f4dda31f4de7502419c4c54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aa4902651f4dda31f4de7502419c4c54d">crend</a> () const noexcept</td></tr>
<tr class="separator:aa4902651f4dda31f4de7502419c4c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda7c5c274cde777e30c121b0edd920"><td class="memItemLeft" align="right" valign="top"><a id="a6bda7c5c274cde777e30c121b0edd920" name="a6bda7c5c274cde777e30c121b0edd920"></a>
<a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">raw_const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>raw_crend</b> () const noexcept</td></tr>
<tr class="separator:a6bda7c5c274cde777e30c121b0edd920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33415d47f540922533926394a7b1670d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a33415d47f540922533926394a7b1670d">front</a> () noexcept</td></tr>
<tr class="separator:a33415d47f540922533926394a7b1670d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f4a7a274d76f6f4690c7eb21eb00a3"><td class="memItemLeft" align="right" valign="top"><a id="ac7f4a7a274d76f6f4690c7eb21eb00a3" name="ac7f4a7a274d76f6f4690c7eb21eb00a3"></a>
value_type&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () const noexcept</td></tr>
<tr class="separator:ac7f4a7a274d76f6f4690c7eb21eb00a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb23b72189664beead3d45d6f2263b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a2fb23b72189664beead3d45d6f2263b8">back</a> () noexcept</td></tr>
<tr class="separator:a2fb23b72189664beead3d45d6f2263b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9270c32a22be202f00909850f63a4cd7"><td class="memItemLeft" align="right" valign="top"><a id="a9270c32a22be202f00909850f63a4cd7" name="a9270c32a22be202f00909850f63a4cd7"></a>
value_type&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () const noexcept</td></tr>
<tr class="separator:a9270c32a22be202f00909850f63a4cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75346c110d6771e8966859e8331d598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aa75346c110d6771e8966859e8331d598">replace</a> (size_type index, value_type repl, size_type n=1) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aa75346c110d6771e8966859e8331d598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a22682bc767a0524894051b1169e1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a7a22682bc767a0524894051b1169e1ad">replace</a> (size_type index, size_type len, value_type repl, size_type n) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a7a22682bc767a0524894051b1169e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922273c932600c5fcf8a9b8ec8bbccc"><td class="memItemLeft" align="right" valign="top"><a id="a3922273c932600c5fcf8a9b8ec8bbccc" name="a3922273c932600c5fcf8a9b8ec8bbccc"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (size_type index, size_type len, value_type repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a3922273c932600c5fcf8a9b8ec8bbccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e304fba808ccb808c6bc2031802c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a17e304fba808ccb808c6bc2031802c62">replace</a> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last, value_type repl, size_type n) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a17e304fba808ccb808c6bc2031802c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1689e4c081c05160518e25c3de7a17d2"><td class="memItemLeft" align="right" valign="top"><a id="a1689e4c081c05160518e25c3de7a17d2" name="a1689e4c081c05160518e25c3de7a17d2"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last, value_type repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a1689e4c081c05160518e25c3de7a17d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3be8d4eb65ae904082b96502d8c8b2"><td class="memItemLeft" align="right" valign="top"><a id="aeb3be8d4eb65ae904082b96502d8c8b2" name="aeb3be8d4eb65ae904082b96502d8c8b2"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last, value_type repl, size_type n) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aeb3be8d4eb65ae904082b96502d8c8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ce620809ddd151d4e58462b91e4efa"><td class="memItemLeft" align="right" valign="top"><a id="af2ce620809ddd151d4e58462b91e4efa" name="af2ce620809ddd151d4e58462b91e4efa"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last, value_type repl, size_type n) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:af2ce620809ddd151d4e58462b91e4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bf73e4e56d35dbba1df0f10f98d921"><td class="memItemLeft" align="right" valign="top"><a id="af0bf73e4e56d35dbba1df0f10f98d921" name="af0bf73e4e56d35dbba1df0f10f98d921"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last, value_type repl, size_type n) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:af0bf73e4e56d35dbba1df0f10f98d921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce6e98ea80ba075887a466fffb44293"><td class="memItemLeft" align="right" valign="top"><a id="a7ce6e98ea80ba075887a466fffb44293" name="a7ce6e98ea80ba075887a466fffb44293"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last, value_type repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a7ce6e98ea80ba075887a466fffb44293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30721c57c77bcb776c35a8329a840f1a"><td class="memItemLeft" align="right" valign="top"><a id="a30721c57c77bcb776c35a8329a840f1a" name="a30721c57c77bcb776c35a8329a840f1a"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last, value_type repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a30721c57c77bcb776c35a8329a840f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8a0b4775ab5a36a5c196c0c7bd813b"><td class="memItemLeft" align="right" valign="top"><a id="a9b8a0b4775ab5a36a5c196c0c7bd813b" name="a9b8a0b4775ab5a36a5c196c0c7bd813b"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last, value_type repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a9b8a0b4775ab5a36a5c196c0c7bd813b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168fef38e1e2263fff4f7ac8c0794044"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a168fef38e1e2263fff4f7ac8c0794044">replace</a> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a168fef38e1e2263fff4f7ac8c0794044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f74783ee5728bac2f573650c43c3c8"><td class="memItemLeft" align="right" valign="top"><a id="a70f74783ee5728bac2f573650c43c3c8" name="a70f74783ee5728bac2f573650c43c3c8"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a70f74783ee5728bac2f573650c43c3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ccaf78a96576060c88715b674ce3db"><td class="memItemLeft" align="right" valign="top"><a id="a20ccaf78a96576060c88715b674ce3db" name="a20ccaf78a96576060c88715b674ce3db"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a20ccaf78a96576060c88715b674ce3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395e03d4e432c8a67240c9322d41394a"><td class="memItemLeft" align="right" valign="top"><a id="a395e03d4e432c8a67240c9322d41394a" name="a395e03d4e432c8a67240c9322d41394a"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>replace</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a395e03d4e432c8a67240c9322d41394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfda37b6b389d441556b3aa83b017ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a5dfda37b6b389d441556b3aa83b017ac">replace</a> (size_type index, size_type count, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a5dfda37b6b389d441556b3aa83b017ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f83b377ec12308b3d1ca6c6831080e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a6f83b377ec12308b3d1ca6c6831080e2">raw_replace</a> (size_type start_byte, size_type byte_count, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;repl) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a6f83b377ec12308b3d1ca6c6831080e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb43767f4d21f636d0761fe94a9e305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aeb43767f4d21f636d0761fe94a9e305e">prepend</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;prependix) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aeb43767f4d21f636d0761fe94a9e305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889bf6e246b47aa138b6f297aa0f88a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a889bf6e246b47aa138b6f297aa0f88a9">append</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;appendix) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a889bf6e246b47aa138b6f297aa0f88a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0436ca9b2fb2104d1d627df9752a791"><td class="memItemLeft" align="right" valign="top"><a id="ae0436ca9b2fb2104d1d627df9752a791" name="ae0436ca9b2fb2104d1d627df9752a791"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;appendix) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ae0436ca9b2fb2104d1d627df9752a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffa9a9bf0ae812f3ffc86460d954360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#afffa9a9bf0ae812f3ffc86460d954360">push_back</a> (value_type cp) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:afffa9a9bf0ae812f3ffc86460d954360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a43a94bc36a82ef1c113d49a8b7bb28"><td class="memItemLeft" align="right" valign="top"><a id="a6a43a94bc36a82ef1c113d49a8b7bb28" name="a6a43a94bc36a82ef1c113d49a8b7bb28"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (value_type cp) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a6a43a94bc36a82ef1c113d49a8b7bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59b0915326a29c308981afc8a461ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a0e59b0915326a29c308981afc8a461ca">operator+</a> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> summand) const &amp;noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a0e59b0915326a29c308981afc8a461ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa993447e938a8b3ff7a4ab59932e0460"><td class="memItemLeft" align="right" valign="top"><a id="aa993447e938a8b3ff7a4ab59932e0460" name="aa993447e938a8b3ff7a4ab59932e0460"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;summand) &amp;&amp;noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aa993447e938a8b3ff7a4ab59932e0460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f8f19d937be8db36eecdf46ec81614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a26f8f19d937be8db36eecdf46ec81614">assign</a> (size_type count, value_type cp) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a26f8f19d937be8db36eecdf46ec81614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67073a3271e8fc9ada156a2255fc8143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a67073a3271e8fc9ada156a2255fc8143">assign</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a67073a3271e8fc9ada156a2255fc8143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bfb0c89a9c8de72296bb4052ff760b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a83bfb0c89a9c8de72296bb4052ff760b">assign</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str, size_type pos, size_type count) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a83bfb0c89a9c8de72296bb4052ff760b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc96166a5a1dc6880ebf1a660de1b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a4bc96166a5a1dc6880ebf1a660de1b43">assign</a> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&amp;str) noexcept(TINY_UTF8_NOEXCEPT &amp;&amp;std::is_nothrow_move_assignable&lt; Allocator &gt;())</td></tr>
<tr class="separator:a4bc96166a5a1dc6880ebf1a660de1b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa367f5e321a6db278e1cd26cd652cadf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa367f5e321a6db278e1cd26cd652cadf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aa367f5e321a6db278e1cd26cd652cadf">assign</a> (T &amp;&amp;str, enable_if_ptr&lt; T, data_type &gt; *={}) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aa367f5e321a6db278e1cd26cd652cadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d31eafe3967e70691333590c641837"><td class="memItemLeft" align="right" valign="top"><a id="a04d31eafe3967e70691333590c641837" name="a04d31eafe3967e70691333590c641837"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (const data_type *str, size_type len) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a04d31eafe3967e70691333590c641837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac988716bf4bb63b3827d009bde913a5f"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:ac988716bf4bb63b3827d009bde913a5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac988716bf4bb63b3827d009bde913a5f">assign</a> (const data_type(&amp;str)[LITLEN]) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ac988716bf4bb63b3827d009bde913a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ed1cf8f8907ba6fac710304c3bb51b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73ed1cf8f8907ba6fac710304c3bb51b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a73ed1cf8f8907ba6fac710304c3bb51b">assign</a> (T &amp;&amp;str, enable_if_ptr&lt; T, value_type &gt; *={}) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a73ed1cf8f8907ba6fac710304c3bb51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616c82fe156f73962faa3509d7da0d82"><td class="memItemLeft" align="right" valign="top"><a id="a616c82fe156f73962faa3509d7da0d82" name="a616c82fe156f73962faa3509d7da0d82"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (const value_type *str, size_type len) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a616c82fe156f73962faa3509d7da0d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb8e39ed682a14862b00eee3a0866bc"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:aadb8e39ed682a14862b00eee3a0866bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aadb8e39ed682a14862b00eee3a0866bc">assign</a> (const value_type(&amp;str)[LITLEN]) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aadb8e39ed682a14862b00eee3a0866bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28e28dddbfe4723d8922673bdd7a6c0"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:ab28e28dddbfe4723d8922673bdd7a6c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ab28e28dddbfe4723d8922673bdd7a6c0">assign</a> (InputIt first, InputIt last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ab28e28dddbfe4723d8922673bdd7a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e92cf2a8bdc095f477b4bccc70c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a3a2e92cf2a8bdc095f477b4bccc70c12">assign</a> (std::initializer_list&lt; value_type &gt; ilist) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a3a2e92cf2a8bdc095f477b4bccc70c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4714e8a64d5837fc84052d13f5d069fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a4714e8a64d5837fc84052d13f5d069fb">insert</a> (size_type pos, value_type cp) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a4714e8a64d5837fc84052d13f5d069fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebccd66e4655854a0d9f33b801adb458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aebccd66e4655854a0d9f33b801adb458">insert</a> (size_type pos, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aebccd66e4655854a0d9f33b801adb458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c27d7ca4531a7d2174ae8e35a55677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ae6c27d7ca4531a7d2174ae8e35a55677">insert</a> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> it, value_type cp) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ae6c27d7ca4531a7d2174ae8e35a55677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029754f9332283b5158f3b963463641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac029754f9332283b5158f3b963463641">insert</a> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> it, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ac029754f9332283b5158f3b963463641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889044fa78c29f198d5d73d78fc8307f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a889044fa78c29f198d5d73d78fc8307f">raw_insert</a> (size_type pos, const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a889044fa78c29f198d5d73d78fc8307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d58aaffce9079d81c6d9d3b0d5eeb87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a6d58aaffce9079d81c6d9d3b0d5eeb87">raw_insert</a> (size_type pos, value_type cp) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a6d58aaffce9079d81c6d9d3b0d5eeb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4871604791e99a0ef83a8b0afc498c7"><td class="memItemLeft" align="right" valign="top"><a id="ab4871604791e99a0ef83a8b0afc498c7" name="ab4871604791e99a0ef83a8b0afc498c7"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> () noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="memdesc:ab4871604791e99a0ef83a8b0afc498c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last codepoint in the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>. <br /></td></tr>
<tr class="separator:ab4871604791e99a0ef83a8b0afc498c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca07ec291edfd06083fd4028df1fcbce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aca07ec291edfd06083fd4028df1fcbce">erase</a> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> pos) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aca07ec291edfd06083fd4028df1fcbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a72806433d6c9d573ca797048da7dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a7a72806433d6c9d573ca797048da7dca">erase</a> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a7a72806433d6c9d573ca797048da7dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba23976e0c2dca728e012484528f5fb"><td class="memItemLeft" align="right" valign="top"><a id="a9ba23976e0c2dca728e012484528f5fb" name="a9ba23976e0c2dca728e012484528f5fb"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a9ba23976e0c2dca728e012484528f5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d6bdc5b4e78ea9557312b62f10c087"><td class="memItemLeft" align="right" valign="top"><a id="a24d6bdc5b4e78ea9557312b62f10c087" name="a24d6bdc5b4e78ea9557312b62f10c087"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a24d6bdc5b4e78ea9557312b62f10c087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046a072fe7c994b3fa26a3f32282ba8b"><td class="memItemLeft" align="right" valign="top"><a id="a046a072fe7c994b3fa26a3f32282ba8b" name="a046a072fe7c994b3fa26a3f32282ba8b"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a046a072fe7c994b3fa26a3f32282ba8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b54f0b4e746e67176db9f41dd02298c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a3b54f0b4e746e67176db9f41dd02298c">erase</a> (size_type pos, size_type len=1) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a3b54f0b4e746e67176db9f41dd02298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa182fcebc6e28df1dc964da45e6d6d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aa182fcebc6e28df1dc964da45e6d6d50">raw_erase</a> (size_type pos, size_type len) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aa182fcebc6e28df1dc964da45e6d6d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d8d00ba8dff7ad3591f85c85bdee36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a21d8d00ba8dff7ad3591f85c85bdee36">substr</a> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last) const noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a21d8d00ba8dff7ad3591f85c85bdee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb8052366bc4041191d01f08d4f81b2"><td class="memItemLeft" align="right" valign="top"><a id="aadb8052366bc4041191d01f08d4f81b2" name="aadb8052366bc4041191d01f08d4f81b2"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>substr</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aadb8052366bc4041191d01f08d4f81b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6e1fed202262076715d4202f0a0148"><td class="memItemLeft" align="right" valign="top"><a id="a7a6e1fed202262076715d4202f0a0148" name="a7a6e1fed202262076715d4202f0a0148"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>substr</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a7a6e1fed202262076715d4202f0a0148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e80c531d676e62b7c375d17fa2bc4a2"><td class="memItemLeft" align="right" valign="top"><a id="a0e80c531d676e62b7c375d17fa2bc4a2" name="a0e80c531d676e62b7c375d17fa2bc4a2"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>substr</b> (<a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> first, <a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> last) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a0e80c531d676e62b7c375d17fa2bc4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0aed33c7a1335c03899f279bbeab25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aac0aed33c7a1335c03899f279bbeab25">substr</a> (size_type pos, size_type len=basic_string::npos) const noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aac0aed33c7a1335c03899f279bbeab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c369450c5176c9ba41e2bdb86a4843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a61c369450c5176c9ba41e2bdb86a4843">raw_substr</a> (size_type start_byte, size_type byte_count) const noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a61c369450c5176c9ba41e2bdb86a4843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b857cb5f118d17fba9cf28ab2585dc"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ab4b857cb5f118d17fba9cf28ab2585dc">find</a> (value_type cp, size_type start_codepoint=0) const noexcept</td></tr>
<tr class="separator:ab4b857cb5f118d17fba9cf28ab2585dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a201b18bc25527f26c11edcfaec9777"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a8a201b18bc25527f26c11edcfaec9777">find</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;pattern, size_type start_codepoint=0) const noexcept</td></tr>
<tr class="separator:a8a201b18bc25527f26c11edcfaec9777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1caa76a972eb451256aa08ff1c191d2"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ab1caa76a972eb451256aa08ff1c191d2">find</a> (const data_type *pattern, size_type start_codepoint=0) const noexcept</td></tr>
<tr class="separator:ab1caa76a972eb451256aa08ff1c191d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e860e721e61515e6e88ad7746450cf4"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a1e860e721e61515e6e88ad7746450cf4">raw_find</a> (value_type cp, size_type start_byte=0) const noexcept</td></tr>
<tr class="separator:a1e860e721e61515e6e88ad7746450cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaf99e819fac5d4e1d35325753bffba"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#accaf99e819fac5d4e1d35325753bffba">raw_find</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;pattern, size_type start_byte=0) const noexcept</td></tr>
<tr class="separator:accaf99e819fac5d4e1d35325753bffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3fb595a3bcebf760c7826aa0675d8a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#abd3fb595a3bcebf760c7826aa0675d8a">raw_find</a> (const data_type *pattern, size_type start_byte=0) const noexcept</td></tr>
<tr class="separator:abd3fb595a3bcebf760c7826aa0675d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655677e44b35ad5a35d7cf3e33d78f8d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a655677e44b35ad5a35d7cf3e33d78f8d">rfind</a> (value_type cp, size_type start_codepoint=basic_string::npos) const noexcept</td></tr>
<tr class="separator:a655677e44b35ad5a35d7cf3e33d78f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7698f8153dba78fd3e6652baf298c58f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a7698f8153dba78fd3e6652baf298c58f">raw_rfind</a> (value_type cp, size_type start_byte=basic_string::npos) const noexcept</td></tr>
<tr class="separator:a7698f8153dba78fd3e6652baf298c58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638af772b92c67a4255c589fa99c28ae"><td class="memItemLeft" align="right" valign="top"><a id="a638af772b92c67a4255c589fa99c28ae" name="a638af772b92c67a4255c589fa99c28ae"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_first_of</b> (const value_type *str, size_type start_codepoint=0) const noexcept</td></tr>
<tr class="memdesc:a638af772b92c67a4255c589fa99c28ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find characters in string. <br /></td></tr>
<tr class="separator:a638af772b92c67a4255c589fa99c28ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f14e65f9ca317650da3b20a2022352b"><td class="memItemLeft" align="right" valign="top"><a id="a1f14e65f9ca317650da3b20a2022352b" name="a1f14e65f9ca317650da3b20a2022352b"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>raw_find_first_of</b> (const value_type *str, size_type start_byte=0) const noexcept</td></tr>
<tr class="separator:a1f14e65f9ca317650da3b20a2022352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e0172aacbc7bb43b452dff41c10435"><td class="memItemLeft" align="right" valign="top"><a id="a76e0172aacbc7bb43b452dff41c10435" name="a76e0172aacbc7bb43b452dff41c10435"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_last_of</b> (const value_type *str, size_type start_codepoint=basic_string::npos) const noexcept</td></tr>
<tr class="separator:a76e0172aacbc7bb43b452dff41c10435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d706a12b7c2eba7e8fea41a7f9cca"><td class="memItemLeft" align="right" valign="top"><a id="a143d706a12b7c2eba7e8fea41a7f9cca" name="a143d706a12b7c2eba7e8fea41a7f9cca"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>raw_find_last_of</b> (const value_type *str, size_type start_byte=basic_string::npos) const noexcept</td></tr>
<tr class="separator:a143d706a12b7c2eba7e8fea41a7f9cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f61e4767ac663ab95ee6c3fa95b2536"><td class="memItemLeft" align="right" valign="top"><a id="a3f61e4767ac663ab95ee6c3fa95b2536" name="a3f61e4767ac663ab95ee6c3fa95b2536"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_first_not_of</b> (const value_type *str, size_type start_codepoint=0) const noexcept</td></tr>
<tr class="memdesc:a3f61e4767ac663ab95ee6c3fa95b2536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find absence of characters in string. <br /></td></tr>
<tr class="separator:a3f61e4767ac663ab95ee6c3fa95b2536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aab96c3e870190378816a858c3a597"><td class="memItemLeft" align="right" valign="top"><a id="ad8aab96c3e870190378816a858c3a597" name="ad8aab96c3e870190378816a858c3a597"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>raw_find_first_not_of</b> (const value_type *str, size_type start_byte=0) const noexcept</td></tr>
<tr class="separator:ad8aab96c3e870190378816a858c3a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f32235a8479973266647e300becc7bb"><td class="memItemLeft" align="right" valign="top"><a id="a1f32235a8479973266647e300becc7bb" name="a1f32235a8479973266647e300becc7bb"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>find_last_not_of</b> (const value_type *str, size_type start_codepoint=basic_string::npos) const noexcept</td></tr>
<tr class="separator:a1f32235a8479973266647e300becc7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4cc40941cf5e5b7268c7ace782c440"><td class="memItemLeft" align="right" valign="top"><a id="a9a4cc40941cf5e5b7268c7ace782c440" name="a9a4cc40941cf5e5b7268c7ace782c440"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>raw_find_last_not_of</b> (const value_type *str, size_type start_byte=basic_string::npos) const noexcept</td></tr>
<tr class="separator:a9a4cc40941cf5e5b7268c7ace782c440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bac8bb9521f783d0e81e4bfb1c081b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a37bac8bb9521f783d0e81e4bfb1c081b">starts_with</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="separator:a37bac8bb9521f783d0e81e4bfb1c081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d96d08341249612aa1ef364e7b12a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ae5d96d08341249612aa1ef364e7b12a9">starts_with</a> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:ae5d96d08341249612aa1ef364e7b12a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0a15e7617dad786d9f3afe9ca6c3d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a4b0a15e7617dad786d9f3afe9ca6c3d5">starts_with</a> (value_type cp) const noexcept</td></tr>
<tr class="separator:a4b0a15e7617dad786d9f3afe9ca6c3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391ffb15b613c78c9fa781106ab59221"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a391ffb15b613c78c9fa781106ab59221"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a391ffb15b613c78c9fa781106ab59221">starts_with</a> (T str, enable_if_ptr&lt; T, data_type &gt; *={}) const noexcept</td></tr>
<tr class="separator:a391ffb15b613c78c9fa781106ab59221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c146fbc4ef8595c8799b89bae279f8"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a31c146fbc4ef8595c8799b89bae279f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a31c146fbc4ef8595c8799b89bae279f8">starts_with</a> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a31c146fbc4ef8595c8799b89bae279f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4689d3c69caabe62b1d8b56134def5a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4689d3c69caabe62b1d8b56134def5a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a4689d3c69caabe62b1d8b56134def5a9">starts_with</a> (T str, enable_if_ptr&lt; T, value_type &gt; *={}) const noexcept</td></tr>
<tr class="separator:a4689d3c69caabe62b1d8b56134def5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e00fef14f818bc586e670fc3d9d26c9"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a2e00fef14f818bc586e670fc3d9d26c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a2e00fef14f818bc586e670fc3d9d26c9">starts_with</a> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a2e00fef14f818bc586e670fc3d9d26c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d939e4c207a1fb58be46cb08ac41bf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a4d939e4c207a1fb58be46cb08ac41bf9">ends_with</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="separator:a4d939e4c207a1fb58be46cb08ac41bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba76ab340d9b7bd832a8322d883aeb30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aba76ab340d9b7bd832a8322d883aeb30">ends_with</a> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:aba76ab340d9b7bd832a8322d883aeb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56559f9447d8f420060ef5cb622fa08b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a56559f9447d8f420060ef5cb622fa08b">ends_with</a> (value_type cp) const noexcept</td></tr>
<tr class="separator:a56559f9447d8f420060ef5cb622fa08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2896b5c8c7f493f07516fbf4ae52ad4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2896b5c8c7f493f07516fbf4ae52ad4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ae2896b5c8c7f493f07516fbf4ae52ad4">ends_with</a> (T str, enable_if_ptr&lt; T, data_type &gt; *={}) const noexcept</td></tr>
<tr class="separator:ae2896b5c8c7f493f07516fbf4ae52ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f778b7103a1937d12a144f8bcbeb5a"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a51f778b7103a1937d12a144f8bcbeb5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a51f778b7103a1937d12a144f8bcbeb5a">ends_with</a> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a51f778b7103a1937d12a144f8bcbeb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ab0b02ea819b6251982c12641afbac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94ab0b02ea819b6251982c12641afbac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a94ab0b02ea819b6251982c12641afbac">ends_with</a> (T str, enable_if_ptr&lt; T, value_type &gt; *={}) const noexcept</td></tr>
<tr class="separator:a94ab0b02ea819b6251982c12641afbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae330a998e220d8a45c513664cee136e2"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:ae330a998e220d8a45c513664cee136e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ae330a998e220d8a45c513664cee136e2">ends_with</a> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:ae330a998e220d8a45c513664cee136e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba2c45c0a29575ee283c1c3bdf56dcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a6ba2c45c0a29575ee283c1c3bdf56dcf">compare</a> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="separator:a6ba2c45c0a29575ee283c1c3bdf56dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffe5a0e6eeb50005b2ba8e603f79e4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a6ffe5a0e6eeb50005b2ba8e603f79e4c">compare</a> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:a6ffe5a0e6eeb50005b2ba8e603f79e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd6b1ada2a0555a6ef29799125d32b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ebd6b1ada2a0555a6ef29799125d32b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a1ebd6b1ada2a0555a6ef29799125d32b">compare</a> (T str, enable_if_ptr&lt; T, data_type &gt; *={}) const noexcept</td></tr>
<tr class="separator:a1ebd6b1ada2a0555a6ef29799125d32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2c1ab8f150a39a9bcc31f822d4a1bf"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:add2c1ab8f150a39a9bcc31f822d4a1bf"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#add2c1ab8f150a39a9bcc31f822d4a1bf">compare</a> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:add2c1ab8f150a39a9bcc31f822d4a1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2363a38906039196bba6c4c5ca7803c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2363a38906039196bba6c4c5ca7803c5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a2363a38906039196bba6c4c5ca7803c5">compare</a> (T str, enable_if_ptr&lt; T, value_type &gt; *={}) const noexcept</td></tr>
<tr class="separator:a2363a38906039196bba6c4c5ca7803c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf145e3cd53402d600a43da60ca3e652"><td class="memTemplParams" colspan="2">template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:abf145e3cd53402d600a43da60ca3e652"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#abf145e3cd53402d600a43da60ca3e652">compare</a> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:abf145e3cd53402d600a43da60ca3e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2061336902dca604bde8c1c9325a27ca"><td class="memItemLeft" align="right" valign="top"><a id="a2061336902dca604bde8c1c9325a27ca" name="a2061336902dca604bde8c1c9325a27ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="memdesc:a2061336902dca604bde8c1c9325a27ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality Comparison Operators. <br /></td></tr>
<tr class="separator:a2061336902dca604bde8c1c9325a27ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06daf8121a720e1529104ae034de4bd8"><td class="memItemLeft" align="right" valign="top"><a id="a06daf8121a720e1529104ae034de4bd8" name="a06daf8121a720e1529104ae034de4bd8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="separator:a06daf8121a720e1529104ae034de4bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2b2820f4969f2abfbe0085b2b20977"><td class="memItemLeft" align="right" valign="top"><a id="ade2b2820f4969f2abfbe0085b2b20977" name="ade2b2820f4969f2abfbe0085b2b20977"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:ade2b2820f4969f2abfbe0085b2b20977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0350fc94f1a83a4bfef7fbd100293f"><td class="memItemLeft" align="right" valign="top"><a id="a1c0350fc94f1a83a4bfef7fbd100293f" name="a1c0350fc94f1a83a4bfef7fbd100293f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:a1c0350fc94f1a83a4bfef7fbd100293f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8494d0a383b10918544e7b574ee0744"><td class="memTemplParams" colspan="2"><a id="ac8494d0a383b10918544e7b574ee0744" name="ac8494d0a383b10918544e7b574ee0744"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8494d0a383b10918544e7b574ee0744"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:ac8494d0a383b10918544e7b574ee0744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5169b851bff239f095b0fd1453d49ae"><td class="memTemplParams" colspan="2"><a id="af5169b851bff239f095b0fd1453d49ae" name="af5169b851bff239f095b0fd1453d49ae"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5169b851bff239f095b0fd1453d49ae"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:af5169b851bff239f095b0fd1453d49ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c05c16e918fab357e228bf2d3c650d5"><td class="memTemplParams" colspan="2"><a id="a7c05c16e918fab357e228bf2d3c650d5" name="a7c05c16e918fab357e228bf2d3c650d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c05c16e918fab357e228bf2d3c650d5"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:a7c05c16e918fab357e228bf2d3c650d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df7743989afaa3c5636ed7675dd3332"><td class="memTemplParams" colspan="2"><a id="a2df7743989afaa3c5636ed7675dd3332" name="a2df7743989afaa3c5636ed7675dd3332"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2df7743989afaa3c5636ed7675dd3332"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:a2df7743989afaa3c5636ed7675dd3332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912d55f3d8dea0ce82f1a155882d7659"><td class="memTemplParams" colspan="2"><a id="a912d55f3d8dea0ce82f1a155882d7659" name="a912d55f3d8dea0ce82f1a155882d7659"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a912d55f3d8dea0ce82f1a155882d7659"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a912d55f3d8dea0ce82f1a155882d7659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fc4a78ddf42c83ad05d20c9a51e7a8"><td class="memTemplParams" colspan="2"><a id="ae3fc4a78ddf42c83ad05d20c9a51e7a8" name="ae3fc4a78ddf42c83ad05d20c9a51e7a8"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:ae3fc4a78ddf42c83ad05d20c9a51e7a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:ae3fc4a78ddf42c83ad05d20c9a51e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450200444f48d1601ce76a75261c6ab8"><td class="memTemplParams" colspan="2"><a id="a450200444f48d1601ce76a75261c6ab8" name="a450200444f48d1601ce76a75261c6ab8"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a450200444f48d1601ce76a75261c6ab8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a450200444f48d1601ce76a75261c6ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4e786bd71755b40c8d90b6e0cdfa40"><td class="memTemplParams" colspan="2"><a id="ace4e786bd71755b40c8d90b6e0cdfa40" name="ace4e786bd71755b40c8d90b6e0cdfa40"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:ace4e786bd71755b40c8d90b6e0cdfa40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:ace4e786bd71755b40c8d90b6e0cdfa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2879bacbddc0dda3ad72ef78ace632e"><td class="memItemLeft" align="right" valign="top"><a id="af2879bacbddc0dda3ad72ef78ace632e" name="af2879bacbddc0dda3ad72ef78ace632e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="memdesc:af2879bacbddc0dda3ad72ef78ace632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical comparison Operators. <br /></td></tr>
<tr class="separator:af2879bacbddc0dda3ad72ef78ace632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a66b29b67d39c6e87ac71c6570904a"><td class="memItemLeft" align="right" valign="top"><a id="a31a66b29b67d39c6e87ac71c6570904a" name="a31a66b29b67d39c6e87ac71c6570904a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="separator:a31a66b29b67d39c6e87ac71c6570904a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eadc68510c04413f00d6ab7913da28f"><td class="memItemLeft" align="right" valign="top"><a id="a4eadc68510c04413f00d6ab7913da28f" name="a4eadc68510c04413f00d6ab7913da28f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="separator:a4eadc68510c04413f00d6ab7913da28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ec9085922b9d243e880f3ed8b26a61"><td class="memItemLeft" align="right" valign="top"><a id="af9ec9085922b9d243e880f3ed8b26a61" name="af9ec9085922b9d243e880f3ed8b26a61"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp;str) const noexcept</td></tr>
<tr class="separator:af9ec9085922b9d243e880f3ed8b26a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9642d8e3a4527ef7989b81b975d1cd02"><td class="memItemLeft" align="right" valign="top"><a id="a9642d8e3a4527ef7989b81b975d1cd02" name="a9642d8e3a4527ef7989b81b975d1cd02"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:a9642d8e3a4527ef7989b81b975d1cd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b734aeb547d1c805eed47793c52ce85"><td class="memItemLeft" align="right" valign="top"><a id="a7b734aeb547d1c805eed47793c52ce85" name="a7b734aeb547d1c805eed47793c52ce85"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:a7b734aeb547d1c805eed47793c52ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c30e2ffefa8b91ef673817756f1359"><td class="memItemLeft" align="right" valign="top"><a id="ab7c30e2ffefa8b91ef673817756f1359" name="ab7c30e2ffefa8b91ef673817756f1359"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:ab7c30e2ffefa8b91ef673817756f1359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc597ea725f64124b8a73c94c3d9ccd"><td class="memItemLeft" align="right" valign="top"><a id="a2fc597ea725f64124b8a73c94c3d9ccd" name="a2fc597ea725f64124b8a73c94c3d9ccd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const std::string &amp;str) const noexcept</td></tr>
<tr class="separator:a2fc597ea725f64124b8a73c94c3d9ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698a289bc6733e030aba0b64bfb33d38"><td class="memTemplParams" colspan="2"><a id="a698a289bc6733e030aba0b64bfb33d38" name="a698a289bc6733e030aba0b64bfb33d38"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a698a289bc6733e030aba0b64bfb33d38"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:a698a289bc6733e030aba0b64bfb33d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312efb678af0a76d2132793e9e3b2a7e"><td class="memTemplParams" colspan="2"><a id="a312efb678af0a76d2132793e9e3b2a7e" name="a312efb678af0a76d2132793e9e3b2a7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a312efb678af0a76d2132793e9e3b2a7e"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:a312efb678af0a76d2132793e9e3b2a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b10d2cbc524be74f26a7c6c33fc28d6"><td class="memTemplParams" colspan="2"><a id="a4b10d2cbc524be74f26a7c6c33fc28d6" name="a4b10d2cbc524be74f26a7c6c33fc28d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b10d2cbc524be74f26a7c6c33fc28d6"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:a4b10d2cbc524be74f26a7c6c33fc28d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92d0e76ca4680b921cc03ad886ea6bf"><td class="memTemplParams" colspan="2"><a id="ab92d0e76ca4680b921cc03ad886ea6bf" name="ab92d0e76ca4680b921cc03ad886ea6bf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab92d0e76ca4680b921cc03ad886ea6bf"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:ab92d0e76ca4680b921cc03ad886ea6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1a77731d056f3d368db5c45d4463a7"><td class="memTemplParams" colspan="2"><a id="acc1a77731d056f3d368db5c45d4463a7" name="acc1a77731d056f3d368db5c45d4463a7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc1a77731d056f3d368db5c45d4463a7"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:acc1a77731d056f3d368db5c45d4463a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad67d958a43d289f3b118763f7efafd"><td class="memTemplParams" colspan="2"><a id="a0ad67d958a43d289f3b118763f7efafd" name="a0ad67d958a43d289f3b118763f7efafd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ad67d958a43d289f3b118763f7efafd"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:a0ad67d958a43d289f3b118763f7efafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f552279fe5566848fad639fd994123c"><td class="memTemplParams" colspan="2"><a id="a0f552279fe5566848fad639fd994123c" name="a0f552279fe5566848fad639fd994123c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f552279fe5566848fad639fd994123c"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:a0f552279fe5566848fad639fd994123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57ec02141a9c1bd404232d70d0f692f"><td class="memTemplParams" colspan="2"><a id="ad57ec02141a9c1bd404232d70d0f692f" name="ad57ec02141a9c1bd404232d70d0f692f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad57ec02141a9c1bd404232d70d0f692f"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (T &amp;&amp;str) const noexcept</td></tr>
<tr class="separator:ad57ec02141a9c1bd404232d70d0f692f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac510fa8cb8cf34e1a75ddacda7c19d28"><td class="memTemplParams" colspan="2"><a id="ac510fa8cb8cf34e1a75ddacda7c19d28" name="ac510fa8cb8cf34e1a75ddacda7c19d28"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:ac510fa8cb8cf34e1a75ddacda7c19d28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:ac510fa8cb8cf34e1a75ddacda7c19d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f1613887ce3ad5aeca4be0bb342011"><td class="memTemplParams" colspan="2"><a id="a80f1613887ce3ad5aeca4be0bb342011" name="a80f1613887ce3ad5aeca4be0bb342011"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a80f1613887ce3ad5aeca4be0bb342011"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a80f1613887ce3ad5aeca4be0bb342011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d988c0c598e8c1b71ababc9b8f17dc4"><td class="memTemplParams" colspan="2"><a id="a4d988c0c598e8c1b71ababc9b8f17dc4" name="a4d988c0c598e8c1b71ababc9b8f17dc4"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a4d988c0c598e8c1b71ababc9b8f17dc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a4d988c0c598e8c1b71ababc9b8f17dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38afd089a4076799a6afe006e36d8046"><td class="memTemplParams" colspan="2"><a id="a38afd089a4076799a6afe006e36d8046" name="a38afd089a4076799a6afe006e36d8046"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a38afd089a4076799a6afe006e36d8046"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const data_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a38afd089a4076799a6afe006e36d8046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc99f03a53e42e7801c94f57356d932"><td class="memTemplParams" colspan="2"><a id="aecc99f03a53e42e7801c94f57356d932" name="aecc99f03a53e42e7801c94f57356d932"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:aecc99f03a53e42e7801c94f57356d932"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:aecc99f03a53e42e7801c94f57356d932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e1e9688743333af9d882dccd9623f8"><td class="memTemplParams" colspan="2"><a id="a21e1e9688743333af9d882dccd9623f8" name="a21e1e9688743333af9d882dccd9623f8"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a21e1e9688743333af9d882dccd9623f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a21e1e9688743333af9d882dccd9623f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6c8bd8520cc4f983585a3ad6f8ea7"><td class="memTemplParams" colspan="2"><a id="a7fb6c8bd8520cc4f983585a3ad6f8ea7" name="a7fb6c8bd8520cc4f983585a3ad6f8ea7"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a7fb6c8bd8520cc4f983585a3ad6f8ea7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:a7fb6c8bd8520cc4f983585a3ad6f8ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f1478b613664bc7ec5e98017b040c"><td class="memTemplParams" colspan="2"><a id="aaa4f1478b613664bc7ec5e98017b040c" name="aaa4f1478b613664bc7ec5e98017b040c"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:aaa4f1478b613664bc7ec5e98017b040c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const value_type(&amp;str)[LITLEN]) const noexcept</td></tr>
<tr class="separator:aaa4f1478b613664bc7ec5e98017b040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb89c282427e56d5c2945fe4428984b"><td class="memItemLeft" align="right" valign="top"><a id="a3cb89c282427e56d5c2945fe4428984b" name="a3cb89c282427e56d5c2945fe4428984b"></a>
width_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_bytes</b> (size_type byte_index) const noexcept</td></tr>
<tr class="memdesc:a3cb89c282427e56d5c2945fe4428984b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes of codepoint in <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>. <br /></td></tr>
<tr class="separator:a3cb89c282427e56d5c2945fe4428984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08560463cb487f9c7abc055b9cd19ba"><td class="memItemLeft" align="right" valign="top"><a id="ad08560463cb487f9c7abc055b9cd19ba" name="ad08560463cb487f9c7abc055b9cd19ba"></a>
width_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_codepoint_bytes</b> (size_type codepoint_index) const noexcept</td></tr>
<tr class="separator:ad08560463cb487f9c7abc055b9cd19ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827e3a1928f1433aefc7a96fdc334d29"><td class="memItemLeft" align="right" valign="top"><a id="a827e3a1928f1433aefc7a96fdc334d29" name="a827e3a1928f1433aefc7a96fdc334d29"></a>
width_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_pre_bytes</b> (size_type byte_index) const noexcept</td></tr>
<tr class="memdesc:a827e3a1928f1433aefc7a96fdc334d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes before a codepoint, that build up a new codepoint. <br /></td></tr>
<tr class="separator:a827e3a1928f1433aefc7a96fdc334d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a8778495a2e0384d2a159ffc2687e8"><td class="memItemLeft" align="right" valign="top"><a id="ad4a8778495a2e0384d2a159ffc2687e8" name="ad4a8778495a2e0384d2a159ffc2687e8"></a>
width_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_codepoint_pre_bytes</b> (size_type codepoint_index) const noexcept</td></tr>
<tr class="separator:ad4a8778495a2e0384d2a159ffc2687e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2132c506f40749200b1da92979e26e8"><td class="memItemLeft" align="right" valign="top"><a id="ad2132c506f40749200b1da92979e26e8" name="ad2132c506f40749200b1da92979e26e8"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>raw_back_index</b> () const noexcept</td></tr>
<tr class="memdesc:ad2132c506f40749200b1da92979e26e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte index of the last codepoint. <br /></td></tr>
<tr class="separator:ad2132c506f40749200b1da92979e26e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf2ebaa94cce53b5376d652c9ca644c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a5cf2ebaa94cce53b5376d652c9ca644c">get_num_codepoints</a> (size_type byte_start, size_type byte_count) const noexcept</td></tr>
<tr class="separator:a5cf2ebaa94cce53b5376d652c9ca644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034c117f8f5db883c9fbeecf048925bd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a034c117f8f5db883c9fbeecf048925bd">get_num_bytes</a> (size_type byte_start, size_type cp_count) const noexcept</td></tr>
<tr class="separator:a034c117f8f5db883c9fbeecf048925bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da60d9af0757f85e7733536e71be293"><td class="memItemLeft" align="right" valign="top"><a id="a9da60d9af0757f85e7733536e71be293" name="a9da60d9af0757f85e7733536e71be293"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_bytes_from_start</b> (size_type cp_count) const noexcept</td></tr>
<tr class="separator:a9da60d9af0757f85e7733536e71be293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de72049ba4769b1b4e131cc32733de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a3de72049ba4769b1b4e131cc32733de5">requires_unicode</a> () const noexcept</td></tr>
<tr class="memdesc:a3de72049ba4769b1b4e131cc32733de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">tinyutf8-specific features  <a href="classtiny__utf8_1_1basic__string.html#a3de72049ba4769b1b4e131cc32733de5">More...</a><br /></td></tr>
<tr class="separator:a3de72049ba4769b1b4e131cc32733de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c4f1252253107d1a681cc4415aca5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ad5c4f1252253107d1a681cc4415aca5b">sso_active</a> () const noexcept</td></tr>
<tr class="separator:ad5c4f1252253107d1a681cc4415aca5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961fe1c91ef8e209b4762f88eca21e5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a961fe1c91ef8e209b4762f88eca21e5d">lut_active</a> () const noexcept</td></tr>
<tr class="separator:a961fe1c91ef8e209b4762f88eca21e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65be8fc22219ec72d04fb2b3b6f3dca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a65be8fc22219ec72d04fb2b3b6f3dca1">to_wide_literal</a> (value_type *dest) const noexcept</td></tr>
<tr class="separator:a65be8fc22219ec72d04fb2b3b6f3dca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1062e38be9de70f1e02ec84899de288"><td class="memItemLeft" align="right" valign="top">std::basic_string&lt; data_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ae1062e38be9de70f1e02ec84899de288">cpp_str</a> (bool prepend_bom=false) const noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:ae1062e38be9de70f1e02ec84899de288"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a2cca7472f3dd133d83232afcd17a9f27"><td class="memTemplParams" colspan="2"><a id="a2cca7472f3dd133d83232afcd17a9f27" name="a2cca7472f3dd133d83232afcd17a9f27"></a>
template&lt;size_type L&gt; </td></tr>
<tr class="memitem:a2cca7472f3dd133d83232afcd17a9f27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_small_string</b> = typename std::enable_if&lt;(L&lt;=SSO::size), bool &gt;::type</td></tr>
<tr class="memdesc:a2cca7472f3dd133d83232afcd17a9f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE helpers for constructors. <br /></td></tr>
<tr class="separator:a2cca7472f3dd133d83232afcd17a9f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4994cd17c1b94440fa4455321bd36127"><td class="memTemplParams" colspan="2"><a id="a4994cd17c1b94440fa4455321bd36127" name="a4994cd17c1b94440fa4455321bd36127"></a>
template&lt;size_type L&gt; </td></tr>
<tr class="memitem:a4994cd17c1b94440fa4455321bd36127"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_not_small_string</b> = typename std::enable_if&lt;(L &gt; SSO::size), bool &gt;::type</td></tr>
<tr class="separator:a4994cd17c1b94440fa4455321bd36127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd2f8de3511cd11c145019d48c1f623"><td class="memTemplParams" colspan="2"><a id="adbd2f8de3511cd11c145019d48c1f623" name="adbd2f8de3511cd11c145019d48c1f623"></a>
template&lt;typename T , typename CharType , typename _DataType  = bool&gt; </td></tr>
<tr class="memitem:adbd2f8de3511cd11c145019d48c1f623"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_ptr</b> = typename std::enable_if&lt; std::is_pointer&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &amp;&amp;std::is_same&lt; CharType, typename std::remove_cv&lt; typename std::remove_pointer&lt; typename std::remove_reference&lt; T &gt;::type &gt;::type &gt;::type &gt;::value, _DataType &gt;::type</td></tr>
<tr class="separator:adbd2f8de3511cd11c145019d48c1f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac402cfbfa983c6e90ba9f48b7fd5c6ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#ac402cfbfa983c6e90ba9f48b7fd5c6ac">set_non_sso_string_len</a> (size_type string_len) noexcept</td></tr>
<tr class="memdesc:ac402cfbfa983c6e90ba9f48b7fd5c6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-static helper methods.  <a href="classtiny__utf8_1_1basic__string.html#ac402cfbfa983c6e90ba9f48b7fd5c6ac">More...</a><br /></td></tr>
<tr class="separator:ac402cfbfa983c6e90ba9f48b7fd5c6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac083b5bd9d2f9cf5f398303144d2604a"><td class="memItemLeft" align="right" valign="top"><a id="ac083b5bd9d2f9cf5f398303144d2604a" name="ac083b5bd9d2f9cf5f398303144d2604a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_non_sso_string_len</b> () const noexcept</td></tr>
<tr class="memdesc:ac083b5bd9d2f9cf5f398303144d2604a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer size, if <a class="el" href="structtiny__utf8_1_1basic__string_1_1_s_s_o.html">SSO</a> is disabled. <br /></td></tr>
<tr class="separator:ac083b5bd9d2f9cf5f398303144d2604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a2ee6e0e98998093fa33773d8c23c"><td class="memItemLeft" align="right" valign="top"><a id="a035a2ee6e0e98998093fa33773d8c23c" name="a035a2ee6e0e98998093fa33773d8c23c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_sso_data_len</b> (unsigned char data_len=0) noexcept</td></tr>
<tr class="memdesc:a035a2ee6e0e98998093fa33773d8c23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data length (also enables <a class="el" href="structtiny__utf8_1_1basic__string_1_1_s_s_o.html">SSO</a>) <br /></td></tr>
<tr class="separator:a035a2ee6e0e98998093fa33773d8c23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79483d8c316830a33edc6607facc9665"><td class="memItemLeft" align="right" valign="top"><a id="a79483d8c316830a33edc6607facc9665" name="a79483d8c316830a33edc6607facc9665"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_sso_data_len</b> () const noexcept</td></tr>
<tr class="memdesc:a79483d8c316830a33edc6607facc9665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data length (when <a class="el" href="structtiny__utf8_1_1basic__string_1_1_s_s_o.html">SSO</a> is active) <br /></td></tr>
<tr class="separator:a79483d8c316830a33edc6607facc9665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936f30756014c05cc74c591983fbcdb5"><td class="memItemLeft" align="right" valign="top"><a id="a936f30756014c05cc74c591983fbcdb5" name="a936f30756014c05cc74c591983fbcdb5"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_non_sso_capacity</b> () const noexcept</td></tr>
<tr class="memdesc:a936f30756014c05cc74c591983fbcdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a good guess of how many codepoints the currently allocated buffer can hold. <br /></td></tr>
<tr class="separator:a936f30756014c05cc74c591983fbcdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a613e7963844cc3dc5a858603bf8ca"><td class="memItemLeft" align="right" valign="top"><a id="a48a613e7963844cc3dc5a858603bf8ca" name="a48a613e7963844cc3dc5a858603bf8ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sso_inactive</b> () const noexcept</td></tr>
<tr class="memdesc:a48a613e7963844cc3dc5a858603bf8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check, if sso is inactive (this operation doesn't require a negation and is faster) <br /></td></tr>
<tr class="separator:a48a613e7963844cc3dc5a858603bf8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723355da319a3167a0f6f216da6ea34c"><td class="memItemLeft" align="right" valign="top"><a id="a723355da319a3167a0f6f216da6ea34c" name="a723355da319a3167a0f6f216da6ea34c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>requires_unicode_sso</b> () const noexcept</td></tr>
<tr class="memdesc:a723355da319a3167a0f6f216da6ea34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check, whether the string contains codepoints &gt; 127. <br /></td></tr>
<tr class="separator:a723355da319a3167a0f6f216da6ea34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc616e1ee5c06faeff4ff0444823917"><td class="memItemLeft" align="right" valign="top"><a id="a8fc616e1ee5c06faeff4ff0444823917" name="a8fc616e1ee5c06faeff4ff0444823917"></a>
const data_type *&#160;</td><td class="memItemRight" valign="bottom"><b>get_buffer</b> () const noexcept</td></tr>
<tr class="memdesc:a8fc616e1ee5c06faeff4ff0444823917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer. <br /></td></tr>
<tr class="separator:a8fc616e1ee5c06faeff4ff0444823917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c18cd67690528887b590a101fd3c02"><td class="memItemLeft" align="right" valign="top"><a id="ae9c18cd67690528887b590a101fd3c02" name="ae9c18cd67690528887b590a101fd3c02"></a>
data_type *&#160;</td><td class="memItemRight" valign="bottom"><b>get_buffer</b> () noexcept</td></tr>
<tr class="separator:ae9c18cd67690528887b590a101fd3c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e80e8a1aa69fd1e768780978bfb5fc"><td class="memItemLeft" align="right" valign="top"><a id="a29e80e8a1aa69fd1e768780978bfb5fc" name="a29e80e8a1aa69fd1e768780978bfb5fc"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_buffer_size</b> () const noexcept</td></tr>
<tr class="memdesc:a29e80e8a1aa69fd1e768780978bfb5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get buffer size (excluding the trailing LUT indicator) <br /></td></tr>
<tr class="separator:a29e80e8a1aa69fd1e768780978bfb5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07ba16a24c10d55b5b84bf17b0c2987"><td class="memItemLeft" align="right" valign="top"><a id="af07ba16a24c10d55b5b84bf17b0c2987" name="af07ba16a24c10d55b5b84bf17b0c2987"></a>
std::basic_string&lt; data_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cpp_str_bom</b> () const noexcept</td></tr>
<tr class="memdesc:af07ba16a24c10d55b5b84bf17b0c2987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an std::string with the UTF-8 BOM prepended. <br /></td></tr>
<tr class="separator:af07ba16a24c10d55b5b84bf17b0c2987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deae40bca9ab4120a71589e6445cb0b"><td class="memItemLeft" align="right" valign="top"><a id="a2deae40bca9ab4120a71589e6445cb0b" name="a2deae40bca9ab4120a71589e6445cb0b"></a>
data_type *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b> (size_type total_buffer_size) const noexcept</td></tr>
<tr class="memdesc:a2deae40bca9ab4120a71589e6445cb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates size_type-aligned storage (make sure, total_buffer_size is a multiple of sizeof(size_type)!) <br /></td></tr>
<tr class="separator:a2deae40bca9ab4120a71589e6445cb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae693e1ff13b74253fe15a26aed706eb7"><td class="memItemLeft" align="right" valign="top"><a id="ae693e1ff13b74253fe15a26aed706eb7" name="ae693e1ff13b74253fe15a26aed706eb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate</b> (data_type *buffer, size_type buffer_size) const noexcept</td></tr>
<tr class="memdesc:ae693e1ff13b74253fe15a26aed706eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates size_type-aligned storage (make sure, buffer_size is a multiple of sizeof(size_type)!) <br /></td></tr>
<tr class="separator:ae693e1ff13b74253fe15a26aed706eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4bc958ddb3ff46bbecf9be81bbc861"><td class="memItemLeft" align="right" valign="top"><a id="afd4bc958ddb3ff46bbecf9be81bbc861" name="afd4bc958ddb3ff46bbecf9be81bbc861"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_string</b> (const data_type *str, size_type pos, size_type count, size_type data_left, const allocator_type &amp;alloc, <a class="el" href="structtiny__utf8_1_1tiny__utf8__detail_1_1read__codepoints__tag.html">tiny_utf8_detail::read_codepoints_tag</a>) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="memdesc:afd4bc958ddb3ff46bbecf9be81bbc861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> from a character literal. <br /></td></tr>
<tr class="separator:afd4bc958ddb3ff46bbecf9be81bbc861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873ef80160fc0c49a575e573e81deda5"><td class="memItemLeft" align="right" valign="top"><a id="a873ef80160fc0c49a575e573e81deda5" name="a873ef80160fc0c49a575e573e81deda5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_string</b> (const data_type *str, size_type count, const allocator_type &amp;alloc, <a class="el" href="structtiny__utf8_1_1tiny__utf8__detail_1_1read__bytes__tag.html">tiny_utf8_detail::read_bytes_tag</a>) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a873ef80160fc0c49a575e573e81deda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a359082cea049a29399a666c525350a7e"><td class="memItemLeft" align="right" valign="top">static constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a359082cea049a29399a666c525350a7e">get_sso_capacity</a> () noexcept</td></tr>
<tr class="memdesc:a359082cea049a29399a666c525350a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static helper methods.  <a href="classtiny__utf8_1_1basic__string.html#a359082cea049a29399a666c525350a7e">More...</a><br /></td></tr>
<tr class="separator:a359082cea049a29399a666c525350a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134dc10d34c134c933893bc8fd0c0277"><td class="memItemLeft" align="right" valign="top"><a id="a134dc10d34c134c933893bc8fd0c0277" name="a134dc10d34c134c933893bc8fd0c0277"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_lut_active</b> (const data_type *lut_base_ptr) noexcept</td></tr>
<tr class="memdesc:a134dc10d34c134c933893bc8fd0c0277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check, if the lut is active using the lut base ptr. <br /></td></tr>
<tr class="separator:a134dc10d34c134c933893bc8fd0c0277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd42c6da537d7ac1d15ffb31944e5dde"><td class="memItemLeft" align="right" valign="top"><a id="acd42c6da537d7ac1d15ffb31944e5dde" name="acd42c6da537d7ac1d15ffb31944e5dde"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>round_up_to_align</b> (size_type val) noexcept</td></tr>
<tr class="memdesc:acd42c6da537d7ac1d15ffb31944e5dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the supplied value to a multiple of sizeof(size_type) <br /></td></tr>
<tr class="separator:acd42c6da537d7ac1d15ffb31944e5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd32c2f3a5651251a06a1b8386b0642"><td class="memItemLeft" align="right" valign="top"><a id="a2fd32c2f3a5651251a06a1b8386b0642" name="a2fd32c2f3a5651251a06a1b8386b0642"></a>
static data_type *&#160;</td><td class="memItemRight" valign="bottom"><b>get_lut_base_ptr</b> (data_type *buffer, size_type buffer_size) noexcept</td></tr>
<tr class="memdesc:a2fd32c2f3a5651251a06a1b8386b0642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the LUT base pointer from buffer and buffer size. <br /></td></tr>
<tr class="separator:a2fd32c2f3a5651251a06a1b8386b0642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd86e3eedf340536c249e6046d3b119"><td class="memItemLeft" align="right" valign="top"><a id="afcd86e3eedf340536c249e6046d3b119" name="afcd86e3eedf340536c249e6046d3b119"></a>
static const data_type *&#160;</td><td class="memItemRight" valign="bottom"><b>get_lut_base_ptr</b> (const data_type *buffer, size_type buffer_size) noexcept</td></tr>
<tr class="separator:afcd86e3eedf340536c249e6046d3b119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6331453443851bb0ddb5bc181eab5eb9"><td class="memItemLeft" align="right" valign="top"><a id="a6331453443851bb0ddb5bc181eab5eb9" name="a6331453443851bb0ddb5bc181eab5eb9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_lut_indiciator</b> (data_type *lut_base_ptr, bool active, size_type lut_len=0) noexcept</td></tr>
<tr class="memdesc:a6331453443851bb0ddb5bc181eab5eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the lut mode indicator. <br /></td></tr>
<tr class="separator:a6331453443851bb0ddb5bc181eab5eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0c02505c0f95bed245f7474c0fb882"><td class="memItemLeft" align="right" valign="top"><a id="a4a0c02505c0f95bed245f7474c0fb882" name="a4a0c02505c0f95bed245f7474c0fb882"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_lut_indicator</b> (data_type *dest, const data_type *source) noexcept</td></tr>
<tr class="memdesc:a4a0c02505c0f95bed245f7474c0fb882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy lut indicator. <br /></td></tr>
<tr class="separator:a4a0c02505c0f95bed245f7474c0fb882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51191587f7afea2878368ede8b4351ed"><td class="memItemLeft" align="right" valign="top"><a id="a51191587f7afea2878368ede8b4351ed" name="a51191587f7afea2878368ede8b4351ed"></a>
static width_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_lut_width</b> (size_type buffer_size) noexcept</td></tr>
<tr class="memdesc:a51191587f7afea2878368ede8b4351ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine, whether we will use a 'std::uint8_t', 'std::uint16_t', 'std::uint32_t' or 'std::uint64_t'-based index table. Returns the number of bytes of the destination data type. <br /></td></tr>
<tr class="separator:a51191587f7afea2878368ede8b4351ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6adcd196ed79a89e292dda4b572b58"><td class="memItemLeft" align="right" valign="top"><a id="aba6adcd196ed79a89e292dda4b572b58" name="aba6adcd196ed79a89e292dda4b572b58"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_lut_worth</b> (size_type pot_lut_len, size_type string_len, bool lut_present, bool biased=true) noexcept</td></tr>
<tr class="memdesc:aba6adcd196ed79a89e292dda4b572b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine, whether or not a LUT is worth to set up. General case: worth below 25%. If LUT present &lt;33,3%, otherwise &lt;16,7%. <br /></td></tr>
<tr class="separator:aba6adcd196ed79a89e292dda4b572b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81a4af30b3a44e9dcff307eb46f31c2"><td class="memItemLeft" align="right" valign="top"><a id="aa81a4af30b3a44e9dcff307eb46f31c2" name="aa81a4af30b3a44e9dcff307eb46f31c2"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>determine_main_buffer_size</b> (size_type data_len, size_type lut_len, width_type *lut_width) noexcept</td></tr>
<tr class="memdesc:aa81a4af30b3a44e9dcff307eb46f31c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the needed buffer size and the needed lut width (excluding the trailling LUT indicator) <br /></td></tr>
<tr class="separator:aa81a4af30b3a44e9dcff307eb46f31c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087480c4736fa90f397f18406030afe7"><td class="memItemLeft" align="right" valign="top"><a id="a087480c4736fa90f397f18406030afe7" name="a087480c4736fa90f397f18406030afe7"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>determine_main_buffer_size</b> (size_type data_len, size_type lut_len, width_type lut_width) noexcept</td></tr>
<tr class="memdesc:a087480c4736fa90f397f18406030afe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the needed buffer size if the lut width is known (excluding the trailling LUT indicator) <br /></td></tr>
<tr class="separator:a087480c4736fa90f397f18406030afe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addeb492d76d0e07ec5279a3649817858"><td class="memItemLeft" align="right" valign="top"><a id="addeb492d76d0e07ec5279a3649817858" name="addeb492d76d0e07ec5279a3649817858"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>determine_main_buffer_size</b> (size_type data_len) noexcept</td></tr>
<tr class="memdesc:addeb492d76d0e07ec5279a3649817858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the needed buffer size if the lut is empty (excluding the trailling LUT indicator) <br /></td></tr>
<tr class="separator:addeb492d76d0e07ec5279a3649817858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f84d52b4f9805989203d4f2f6d5d8e"><td class="memItemLeft" align="right" valign="top"><a id="a13f84d52b4f9805989203d4f2f6d5d8e" name="a13f84d52b4f9805989203d4f2f6d5d8e"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>determine_total_buffer_size</b> (size_type main_buffer_size) noexcept</td></tr>
<tr class="memdesc:a13f84d52b4f9805989203d4f2f6d5d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but this time including the LUT indicator. <br /></td></tr>
<tr class="separator:a13f84d52b4f9805989203d4f2f6d5d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39aa73f270553ef2818b34a7f35bfcd"><td class="memItemLeft" align="right" valign="top"><a id="ac39aa73f270553ef2818b34a7f35bfcd" name="ac39aa73f270553ef2818b34a7f35bfcd"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_lut</b> (const data_type *iter, width_type lut_width) noexcept</td></tr>
<tr class="memdesc:ac39aa73f270553ef2818b34a7f35bfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth index within a multibyte index table. <br /></td></tr>
<tr class="separator:ac39aa73f270553ef2818b34a7f35bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e5feed3dd7e168d40a4bfefc15fe3"><td class="memItemLeft" align="right" valign="top"><a id="a3d4e5feed3dd7e168d40a4bfefc15fe3" name="a3d4e5feed3dd7e168d40a4bfefc15fe3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_lut</b> (data_type *iter, width_type lut_width, size_type value) noexcept</td></tr>
<tr class="separator:a3d4e5feed3dd7e168d40a4bfefc15fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac46d1bca3365fc7c3311067656a4cfb"><td class="memItemLeft" align="right" valign="top"><a id="aac46d1bca3365fc7c3311067656a4cfb" name="aac46d1bca3365fc7c3311067656a4cfb"></a>
static size_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_lut_len</b> (const data_type *lut_base_ptr) noexcept</td></tr>
<tr class="memdesc:aac46d1bca3365fc7c3311067656a4cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the LUT size (given the lut is active!) <br /></td></tr>
<tr class="separator:aac46d1bca3365fc7c3311067656a4cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5950f57460a41d511a735cdf98987d"><td class="memItemLeft" align="right" valign="top">static width_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a9b5950f57460a41d511a735cdf98987d">get_codepoint_bytes</a> (data_type first_byte, size_type data_left) noexcept</td></tr>
<tr class="separator:a9b5950f57460a41d511a735cdf98987d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d76d566d0fdaea25c64ed7b316777ee"><td class="memItemLeft" align="right" valign="top">static width_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a8d76d566d0fdaea25c64ed7b316777ee">get_codepoint_bytes</a> (value_type cp) noexcept</td></tr>
<tr class="separator:a8d76d566d0fdaea25c64ed7b316777ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aef3bef417e95290367f8d2fd35c72"><td class="memItemLeft" align="right" valign="top"><a id="a34aef3bef417e95290367f8d2fd35c72" name="a34aef3bef417e95290367f8d2fd35c72"></a>
static width_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_bytes_of_utf8_char_before</b> (const data_type *data_start, size_type index) noexcept</td></tr>
<tr class="memdesc:a34aef3bef417e95290367f8d2fd35c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes to expect before this one (including this one) that belong to this utf8 char. <br /></td></tr>
<tr class="separator:a34aef3bef417e95290367f8d2fd35c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1689c44499db835bf6d2140e652c53"><td class="memItemLeft" align="right" valign="top"><a id="a7f1689c44499db835bf6d2140e652c53" name="a7f1689c44499db835bf6d2140e652c53"></a>
static value_type&#160;</td><td class="memItemRight" valign="bottom"><b>decode_utf8</b> (const data_type *data, width_type num_bytes) noexcept</td></tr>
<tr class="memdesc:a7f1689c44499db835bf6d2140e652c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a given input of rle utf8 data to a unicode codepoint, given the number of bytes it's made of. <br /></td></tr>
<tr class="separator:a7f1689c44499db835bf6d2140e652c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf07745d4c21d44ffb5f461c4e751d5d"><td class="memItemLeft" align="right" valign="top">static width_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#adf07745d4c21d44ffb5f461c4e751d5d">decode_utf8_and_len</a> (const data_type *data, value_type &amp;dest, size_type data_left) noexcept</td></tr>
<tr class="separator:adf07745d4c21d44ffb5f461c4e751d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752a8bc0643ac14d33acc92237b31a90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#a752a8bc0643ac14d33acc92237b31a90">encode_utf8</a> (value_type cp, data_type *dest, width_type cp_bytes) noexcept</td></tr>
<tr class="separator:a752a8bc0643ac14d33acc92237b31a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab61d52e23cc2481787533f78d33ec75"><td class="memItemLeft" align="right" valign="top">static width_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiny__utf8_1_1basic__string.html#aab61d52e23cc2481787533f78d33ec75">encode_utf8</a> (value_type cp, data_type *dest) noexcept</td></tr>
<tr class="separator:aab61d52e23cc2481787533f78d33ec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0697a2ddeb1517597ab9e5bf39da27c3"><td class="memTemplParams" colspan="2"><a id="a0697a2ddeb1517597ab9e5bf39da27c3" name="a0697a2ddeb1517597ab9e5bf39da27c3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0697a2ddeb1517597ab9e5bf39da27c3"><td class="memTemplItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_msb_mask</b> (width_type bytes=sizeof(T)) noexcept</td></tr>
<tr class="separator:a0697a2ddeb1517597ab9e5bf39da27c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1fc82fee95029a25da07322fcf794c5c"><td class="memItemLeft" ><a id="a1fc82fee95029a25da07322fcf794c5c" name="a1fc82fee95029a25da07322fcf794c5c"></a>
union {</td></tr>
<tr class="memitem:ae191a136254d3b6d6551c81d34cba08e"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="structtiny__utf8_1_1basic__string_1_1_s_s_o.html">SSO</a>&#160;&#160;&#160;<b>t_sso</b></td></tr>
<tr class="separator:ae191a136254d3b6d6551c81d34cba08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b8dd9c369da73cdd58d10bb7ab4fcf"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="structtiny__utf8_1_1basic__string_1_1_n_o_n___s_s_o.html">NON_SSO</a>&#160;&#160;&#160;<b>t_non_sso</b></td></tr>
<tr class="separator:a34b8dd9c369da73cdd58d10bb7ab4fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc82fee95029a25da07322fcf794c5c"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:a1fc82fee95029a25da07322fcf794c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes. <br /></td></tr>
<tr class="separator:a1fc82fee95029a25da07322fcf794c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7dabbfb2dbeaa6e0f5ff963efc132a48"><td class="memItemLeft" align="right" valign="top"><a id="a7dabbfb2dbeaa6e0f5ff963efc132a48" name="a7dabbfb2dbeaa6e0f5ff963efc132a48"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> lhs, data_type rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a7dabbfb2dbeaa6e0f5ff963efc132a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47188af6ed2e9d767210131888d3a49"><td class="memItemLeft" align="right" valign="top"><a id="af47188af6ed2e9d767210131888d3a49" name="af47188af6ed2e9d767210131888d3a49"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> lhs, value_type rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:af47188af6ed2e9d767210131888d3a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784bec7edf7e93da1050c6a13133b8e3"><td class="memTemplParams" colspan="2"><a id="a784bec7edf7e93da1050c6a13133b8e3" name="a784bec7edf7e93da1050c6a13133b8e3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a784bec7edf7e93da1050c6a13133b8e3"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> lhs, T &amp;&amp;rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a784bec7edf7e93da1050c6a13133b8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ab06faf571fef1f5b93202be28be46"><td class="memTemplParams" colspan="2"><a id="a72ab06faf571fef1f5b93202be28be46" name="a72ab06faf571fef1f5b93202be28be46"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72ab06faf571fef1f5b93202be28be46"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> lhs, T &amp;&amp;rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a72ab06faf571fef1f5b93202be28be46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ce7c7beec83a2dfbcb001cfc8aa542"><td class="memTemplParams" colspan="2"><a id="a64ce7c7beec83a2dfbcb001cfc8aa542" name="a64ce7c7beec83a2dfbcb001cfc8aa542"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a64ce7c7beec83a2dfbcb001cfc8aa542"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> lhs, const data_type(&amp;rhs)[LITLEN]) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a64ce7c7beec83a2dfbcb001cfc8aa542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5730244520a9f25f482d363490010358"><td class="memTemplParams" colspan="2"><a id="a5730244520a9f25f482d363490010358" name="a5730244520a9f25f482d363490010358"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a5730244520a9f25f482d363490010358"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> lhs, const value_type(&amp;rhs)[LITLEN]) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a5730244520a9f25f482d363490010358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2f455a79f651d74c914ef078120b97"><td class="memItemLeft" align="right" valign="top"><a id="aba2f455a79f651d74c914ef078120b97" name="aba2f455a79f651d74c914ef078120b97"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (data_type lhs, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:aba2f455a79f651d74c914ef078120b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3629e23739acace3e93923b3cb1bca"><td class="memItemLeft" align="right" valign="top"><a id="a5d3629e23739acace3e93923b3cb1bca" name="a5d3629e23739acace3e93923b3cb1bca"></a>
<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (value_type lhs, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a5d3629e23739acace3e93923b3cb1bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e14fa5a541aeb6495ed2be2db36fa"><td class="memTemplParams" colspan="2"><a id="a4a2e14fa5a541aeb6495ed2be2db36fa" name="a4a2e14fa5a541aeb6495ed2be2db36fa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a2e14fa5a541aeb6495ed2be2db36fa"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, data_type, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (T &amp;&amp;lhs, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a4a2e14fa5a541aeb6495ed2be2db36fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ffecf372a3f614ed55b609750b347"><td class="memTemplParams" colspan="2"><a id="a464ffecf372a3f614ed55b609750b347" name="a464ffecf372a3f614ed55b609750b347"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a464ffecf372a3f614ed55b609750b347"><td class="memTemplItemLeft" align="right" valign="top">enable_if_ptr&lt; T, value_type, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (T &amp;&amp;lhs, <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a464ffecf372a3f614ed55b609750b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594b92e69b1b0b18ca9e48e4eefccbfb"><td class="memTemplParams" colspan="2"><a id="a594b92e69b1b0b18ca9e48e4eefccbfb" name="a594b92e69b1b0b18ca9e48e4eefccbfb"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a594b92e69b1b0b18ca9e48e4eefccbfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const data_type(&amp;lhs)[LITLEN], <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a594b92e69b1b0b18ca9e48e4eefccbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598f445d6aad14c47f89ee3d07cbbe58"><td class="memTemplParams" colspan="2"><a id="a598f445d6aad14c47f89ee3d07cbbe58" name="a598f445d6aad14c47f89ee3d07cbbe58"></a>
template&lt;size_type LITLEN&gt; </td></tr>
<tr class="memitem:a598f445d6aad14c47f89ee3d07cbbe58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const value_type(&amp;lhs)[LITLEN], <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> rhs) noexcept(TINY_UTF8_NOEXCEPT)</td></tr>
<tr class="separator:a598f445d6aad14c47f89ee3d07cbbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab338206fe59efb7b1aeb577bb8586cf9" name="ab338206fe59efb7b1aeb577bb8586cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab338206fe59efb7b1aeb577bb8586cf9">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default Ctor</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that is empty </dd></dl>

</div>
</div>
<a id="afe7e5324bc1ad45530098ab3447404b2" name="afe7e5324bc1ad45530098ab3447404b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7e5324bc1ad45530098ab3447404b2">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Ctor taking an alloc</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that is empty </dd></dl>

</div>
</div>
<a id="a065b100aa8861f0c24ad46bfaad7c119" name="a065b100aa8861f0c24ad46bfaad7c119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065b100aa8861f0c24ad46bfaad7c119">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, data_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an utf8 sequence and the maximum length to read from it (in number of codepoints)</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that holds the given utf8 sequence </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 sequence to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">pos</td><td>(Optional) The codepoint position of the first codepoint to read </td></tr>
    <tr><td class="paramname">len</td><td>(Optional) The maximum number of codepoints to read from the sequence </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2575d024d10dbd30774dad39667b8b15" name="a2575d024d10dbd30774dad39667b8b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2575d024d10dbd30774dad39667b8b15">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const data_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an utf8 sequence and the maximum length to read from it (in number of codepoints)</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that holds the given utf8 sequence </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 sequence to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of codepoints to read from the sequence </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab065cce333f0ceedbdd69dc3e69c3ca3" name="ab065cce333f0ceedbdd69dc3e69c3ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab065cce333f0ceedbdd69dc3e69c3ca3">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const data_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an utf8 sequence, a codepoint position to start reading from the sequence and the maximum length to read from it (in number of codepoints)</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that holds the given utf8 sequence </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 sequence to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">pos</td><td>The codepoint position of the first codepoint to read </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of codepoints to read from the sequence </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa4ce46ecb8d0f86098cb9c18ecef656" name="aaa4ce46ecb8d0f86098cb9c18ecef656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4ce46ecb8d0f86098cb9c18ecef656">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const data_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiny__utf8_1_1basic__string.html#a2cca7472f3dd133d83232afcd17a9f27">enable_if_small_string</a>&lt; LITLEN &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an utf8 char literal</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that holds the given utf8 sequence </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 literal to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">pos</td><td>(Optional) The position of the first codepoint to read (bounds-checked) </td></tr>
    <tr><td class="paramname">len</td><td>(Optional) The maximum number of codepoints to read from the sequence </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecc6ce18e0aa93e7821fe8771b2c8874" name="aecc6ce18e0aa93e7821fe8771b2c8874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc6ce18e0aa93e7821fe8771b2c8874">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const data_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an utf8 char literal and the maximum number of codepoints to read</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that holds the given utf8 sequence </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 literal to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of codepoints to read from the sequence </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac201c79ff44c60bb093c76b8a6bab827" name="ac201c79ff44c60bb093c76b8a6bab827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201c79ff44c60bb093c76b8a6bab827">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const data_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an utf8 char literal, a codepoint position to start reading from the sequence and the maximum number of codepoints to read</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that holds the given utf8 sequence </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 literal to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">pos</td><td>The codepoint position of the first codepoint to read (bounds-checked) </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of codepoints to read from the sequence </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d82a8d454ad5306dd6659392329ce9" name="a03d82a8d454ad5306dd6659392329ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d82a8d454ad5306dd6659392329ce9">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename C , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; data_type, C, A &gt;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an std::string</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> copying the string data from the supplied std::basic_string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string object from which the data will be copied (interpreted as UTF-8) </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83f31a2cac7ab8f46b3e5f69fe6e0bdd" name="a83f31a2cac7ab8f46b3e5f69fe6e0bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f31a2cac7ab8f46b3e5f69fe6e0bdd">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename C , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; data_type, C, A &gt;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an std::string</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> copying the string data from the supplied std::basic_string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string object from which the data will be copied (interpreted as UTF-8) </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of codepoints to read from 'str' </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f26be2b043990c8c73be8ed12139cda" name="a4f26be2b043990c8c73be8ed12139cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f26be2b043990c8c73be8ed12139cda">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor that fills the string with a certain amount of codepoints</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that gets filled with 'n' codepoints </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of codepoints generated </td></tr>
    <tr><td class="paramname">cp</td><td>The codepoint that the whole buffer will be set to </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5efb35075738c63e08dd9739f3bbe1e" name="aa5efb35075738c63e08dd9739f3bbe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5efb35075738c63e08dd9739f3bbe1e">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor that fills the string with a certain amount of characters</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that gets filled with 'n' characters </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of characters generated </td></tr>
    <tr><td class="paramname">cp</td><td>The characters that the whole buffer will be set to </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac91e044d8a99b592669c9876b3cd0c96" name="ac91e044d8a99b592669c9876b3cd0c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91e044d8a99b592669c9876b3cd0c96">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt;&#160;ValueType,&#160;DataType,&#160;Allocator&#160;&gt;::npos</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructs the string with a portion of the supplied string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string that the constructed string shall be a substring of </td></tr>
    <tr><td class="paramname">pos</td><td>The codepoint position indicating the start of the string to be used for construction </td></tr>
    <tr><td class="paramname">count</td><td>The number of codepoints to be taken from 'str' </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a255363c4d2a4dbaddde22855b47829cc" name="a255363c4d2a4dbaddde22855b47829cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255363c4d2a4dbaddde22855b47829cc">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructs the string from the range of codepoints supplied. The resulting string will equal [first,last)</p>
<dl class="section note"><dt>Note</dt><dd>The Range is expected to contain codepoints (rather than code units, i.e. bytes) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range to construct from </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range </td></tr>
    <tr><td class="paramname">alloc</td><td>(Optional) The allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3ba0ad060e28bd0bce5a83010665626" name="aa3ba0ad060e28bd0bce5a83010665626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ba0ad060e28bd0bce5a83010665626">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Copy Constructor that copies the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to construct the string</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that has the exact same data and allocator as 'str' </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6e7d57ebc545f5fa3e86eadb67eb799" name="ad6e7d57ebc545f5fa3e86eadb67eb799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e7d57ebc545f5fa3e86eadb67eb799">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Copy Constructor that copies the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to construct the string</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that has the exact same data as 'str' </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to copy from </td></tr>
    <tr><td class="paramname">alloc</td><td>The new allocator instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac847816999b619f749e4e5f95f33d383" name="ac847816999b619f749e4e5f95f33d383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847816999b619f749e4e5f95f33d383">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">const value_type *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking a wide codepoint literal that will be copied to construct this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that holds the given codepoints The data itself will be first converted to UTF-8 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The codepoint sequence to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">len</td><td>(Optional) The maximum number of codepoints to read from the sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a549605139f453e093c6a03533f3304ed" name="a549605139f453e093c6a03533f3304ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549605139f453e093c6a03533f3304ed">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor taking an initializer list of codepoints.</p>
<dl class="section note"><dt>Note</dt><dd>The initializer list is expected to contain codepoints (rather than code units, i.e. bytes) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list with the contents to be applied to this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06ef4f2bd71cdd4c4c1d74747b99e519" name="a06ef4f2bd71cdd4c4c1d74747b99e519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ef4f2bd71cdd4c4c1d74747b99e519">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor that fills the string with the supplied codepoint</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that gets filled with 'n' codepoints </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint written at the beginning of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c9bf577943a8f9fab5414c1cd99e94e" name="a7c9bf577943a8f9fab5414c1cd99e94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9bf577943a8f9fab5414c1cd99e94e">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype">data_type&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor that fills the string with the supplied character</p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that gets filled with 'n' codepoints </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The codepoint written at the beginning of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f8928cc6556795908e48cbd7c0f4b73" name="a0f8928cc6556795908e48cbd7c0f4b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8928cc6556795908e48cbd7c0f4b73">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Move Constructor that moves the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> content into the new <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that takes all data as well as the allocator from 'str' The supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> is invalid afterwards and may not be used anymore </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb828ec4b048102a9a78412996b9e84c" name="aeb828ec4b048102a9a78412996b9e84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb828ec4b048102a9a78412996b9e84c">&#9670;&nbsp;</a></span>basic_string() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::basic_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Move Constructor that moves the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> content into the new <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Creates an Instance of type <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> that takes all data from 'str' The supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> is invalid afterwards and may not be used anymore </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d4218f2887c7a67397f57bc4856b320" name="a7d4218f2887c7a67397f57bc4856b320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4218f2887c7a67397f57bc4856b320">&#9670;&nbsp;</a></span>~basic_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::~<a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destructor</p>
<dl class="section note"><dt>Note</dt><dd>Destructs a <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> at the end of its lifetime releasing all held memory </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a889bf6e246b47aa138b6f297aa0f88a9" name="a889bf6e246b47aa138b6f297aa0f88a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889bf6e246b47aa138b6f297aa0f88a9">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; V, D, A &gt; &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>appendix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Appends the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">appendix</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to be appended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the supplied string appended </dd></dl>
<p >Ok, obviously no small string, we have to update the data, the lut and the number of codepoints</p>

</div>
</div>
<a id="a4bc96166a5a1dc6880ebf1a660de1b43" name="a4bc96166a5a1dc6880ebf1a660de1b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc96166a5a1dc6880ebf1a660de1b43">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Moves the contents out of the supplied string into this one</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> this string shall move from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, updated to the new string </dd></dl>

</div>
</div>
<a id="a67073a3271e8fc9ada156a2255fc8143" name="a67073a3271e8fc9ada156a2255fc8143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67073a3271e8fc9ada156a2255fc8143">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the contents of this string to a copy of the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> this string shall be made a copy of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, updated to the new string </dd></dl>

</div>
</div>
<a id="a83bfb0c89a9c8de72296bb4052ff760b" name="a83bfb0c89a9c8de72296bb4052ff760b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bfb0c89a9c8de72296bb4052ff760b">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the contents of this string to a substring of the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> this string shall be constructed a substring of </td></tr>
    <tr><td class="paramname">pos</td><td>The codepoint position indicating the start of the string to be used for construction </td></tr>
    <tr><td class="paramname">cp</td><td>The number of codepoints to be taken from 'str' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, updated to the new string </dd></dl>

</div>
</div>
<a id="ac988716bf4bb63b3827d009bde913a5f" name="ac988716bf4bb63b3827d009bde913a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac988716bf4bb63b3827d009bde913a5f">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const data_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assigns an utf8 char literal to this string (with possibly embedded '\0's)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 literal to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadb8e39ed682a14862b00eee3a0866bc" name="aadb8e39ed682a14862b00eee3a0866bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb8e39ed682a14862b00eee3a0866bc">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const value_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assigns an utf-32 char literal to this string (with possibly embedded '\0's)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-32 literal to fill the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab28e28dddbfe4723d8922673bdd7a6c0" name="ab28e28dddbfe4723d8922673bdd7a6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28e28dddbfe4723d8922673bdd7a6c0">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assigns the range of codepoints supplied to this string. The resulting string will equal [first,last)</p>
<dl class="section note"><dt>Note</dt><dd>The Range is expected to contain codepoints (rather than code units, i.e. bytes) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range to read from </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26f8f19d937be8db36eecdf46ec81614" name="a26f8f19d937be8db36eecdf46ec81614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f8f19d937be8db36eecdf46ec81614">&#9670;&nbsp;</a></span>assign() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the contents of this string to 'count' times 'cp'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of times the supplied codepoint is to be repeated </td></tr>
    <tr><td class="paramname">cp</td><td>The codepoint to repeat 'count' times </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, updated to the new string </dd></dl>

</div>
</div>
<a id="a3a2e92cf2a8bdc095f477b4bccc70c12" name="a3a2e92cf2a8bdc095f477b4bccc70c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2e92cf2a8bdc095f477b4bccc70c12">&#9670;&nbsp;</a></span>assign() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assigns the supplied initializer list of codepoints to this string.</p>
<dl class="section note"><dt>Note</dt><dd>The initializer list is expected to contain codepoints (rather than code units, i.e. bytes) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>The initializer list with the contents to be applied to this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa367f5e321a6db278e1cd26cd652cadf" name="aa367f5e321a6db278e1cd26cd652cadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa367f5e321a6db278e1cd26cd652cadf">&#9670;&nbsp;</a></span>assign() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, data_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assigns an utf8 sequence and the maximum length to read from it (in number of codepoints) to this string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 sequence to fill the this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">len</td><td>(Optional) The maximum number of codepoints to read from the sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ed1cf8f8907ba6fac710304c3bb51b" name="a73ed1cf8f8907ba6fac710304c3bb51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ed1cf8f8907ba6fac710304c3bb51b">&#9670;&nbsp;</a></span>assign() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, value_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assigns an utf-32 sequence and the maximum length to read from it (in number of codepoints) to this string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The UTF-8 sequence to fill the this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with </td></tr>
    <tr><td class="paramname">len</td><td>(Optional) The maximum number of codepoints to read from the sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afec8397bb2afb04f6549f53fcd2c62bd" name="afec8397bb2afb04f6549f53fcd2c62bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec8397bb2afb04f6549f53fcd2c62bd">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the codepoint at the supplied index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The codepoint index of the codepoint to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepoint at position 'n' </dd></dl>

</div>
</div>
<a id="a2fb23b72189664beead3d45d6f2263b8" name="a2fb23b72189664beead3d45d6f2263b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb23b72189664beead3d45d6f2263b8">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_reference</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a reference to the last codepoint in the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper to the last codepoint in the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </dd></dl>

</div>
</div>
<a id="aa18db48fef0ee0129a37111302961900" name="aa18db48fef0ee0129a37111302961900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18db48fef0ee0129a37111302961900">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get an iterator to the beginning of the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>An iterator class pointing to the beginning of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </dd></dl>

</div>
</div>
<a id="a131f60eb7a33b62bf407a07d043dffe6" name="a131f60eb7a33b62bf407a07d043dffe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131f60eb7a33b62bf407a07d043dffe6">&#9670;&nbsp;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const data_type * <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the raw data contained in this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Returns the UTF-8 formatted content of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 formatted data, trailled by a '\0' </dd></dl>

</div>
</div>
<a id="ae2b8082304775f237b50da66aaeb84e1" name="ae2b8082304775f237b50da66aaeb84e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b8082304775f237b50da66aaeb84e1">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the current capacity of this string. That is, the number of codepoints it can hold without reallocation</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes currently allocated </dd></dl>

</div>
</div>
<a id="a95be3c884b6d0a33d3a486f3027f23bc" name="a95be3c884b6d0a33d3a486f3027f23bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95be3c884b6d0a33d3a486f3027f23bc">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1const__iterator.html">const_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a const iterator to the beginning of the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator class pointing to the beginning of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which cannot alter things inside this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </dd></dl>

</div>
</div>
<a id="a04c333b1abff8337425b7f0cce46f52d" name="a04c333b1abff8337425b7f0cce46f52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c333b1abff8337425b7f0cce46f52d">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1const__iterator.html">const_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get an iterator to the end of the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator class, which cannot alter this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, pointing to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, that is pointing behind the last codepoint </dd></dl>

</div>
</div>
<a id="a3b833384a9a89159c5276d79e10f5af4" name="a3b833384a9a89159c5276d79e10f5af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b833384a9a89159c5276d79e10f5af4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Clears the content of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Resets the data to an empty string ("") </dd></dl>

</div>
</div>
<a id="a6ba2c45c0a29575ee283c1c3bdf56dcf" name="a6ba2c45c0a29575ee283c1c3bdf56dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba2c45c0a29575ee283c1c3bdf56dcf">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compare this string with the supplied one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to compare this one with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 They compare equal &lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. &gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </dd></dl>

</div>
</div>
<a id="add2c1ab8f150a39a9bcc31f822d4a1bf" name="add2c1ab8f150a39a9bcc31f822d4a1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2c1ab8f150a39a9bcc31f822d4a1bf">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const data_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compares this string with the supplied one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a string literal with possibly embedded zeros, interpreted as UTF-8. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 They compare equal &lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. &gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </dd></dl>

</div>
</div>
<a id="a6ffe5a0e6eeb50005b2ba8e603f79e4c" name="a6ffe5a0e6eeb50005b2ba8e603f79e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffe5a0e6eeb50005b2ba8e603f79e4c">&#9670;&nbsp;</a></span>compare() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compare this string with the supplied one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to compare this one with, interpreted as UTF-8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 They compare equal &lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. &gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </dd></dl>

</div>
</div>
<a id="abf145e3cd53402d600a43da60ca3e652" name="abf145e3cd53402d600a43da60ca3e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf145e3cd53402d600a43da60ca3e652">&#9670;&nbsp;</a></span>compare() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const value_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compares this string with the supplied one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a string literal with possibly embedded zeros, interpreted as UTF-32. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 They compare equal &lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. &gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </dd></dl>

</div>
</div>
<a id="a1ebd6b1ada2a0555a6ef29799125d32b" name="a1ebd6b1ada2a0555a6ef29799125d32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebd6b1ada2a0555a6ef29799125d32b">&#9670;&nbsp;</a></span>compare() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, data_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compares this string with the supplied one. The supplied string literal is assumed to end at the (possibly trailling) '\0'. This is especially important, if this utf8 string contains embedded zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated string literal, interpreted as UTF-8. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 They compare equal &lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. &gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </dd></dl>

</div>
</div>
<a id="a2363a38906039196bba6c4c5ca7803c5" name="a2363a38906039196bba6c4c5ca7803c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2363a38906039196bba6c4c5ca7803c5">&#9670;&nbsp;</a></span>compare() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, value_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compares this string with the supplied one. Thes supplied string literal is assumed to end at the (possibly trailling) '\0'. This is especially important, if this utf8 string contains embedded zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a null-terminated string literal, interpreted as UTF-32. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 They compare equal &lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. &gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </dd></dl>

</div>
</div>
<a id="ae1062e38be9de70f1e02ec84899de288" name="ae1062e38be9de70f1e02ec84899de288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1062e38be9de70f1e02ec84899de288">&#9670;&nbsp;</a></span>cpp_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; data_type &gt; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::cpp_str </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepend_bom</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the raw data contained in this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> wrapped by an std::string</p>
<dl class="section note"><dt>Note</dt><dd>Returns the UTF-8 formatted content of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 formatted data, wrapped inside an std::string </dd></dl>

</div>
</div>
<a id="ad33be9b59b9ce309e2471f9425350d3e" name="ad33be9b59b9ce309e2471f9425350d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33be9b59b9ce309e2471f9425350d3e">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a const reverse iterator to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A const reverse iterator class, which cannot alter this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, pointing to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, that is exactly to the last codepoint </dd></dl>

</div>
</div>
<a id="aa4902651f4dda31f4de7502419c4c54d" name="aa4902651f4dda31f4de7502419c4c54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4902651f4dda31f4de7502419c4c54d">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a const reverse iterator to the beginning of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A const reverse iterator class, which cannot alter this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, pointing to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, that is pointing before the first codepoint </dd></dl>

</div>
</div>
<a id="adf07745d4c21d44ffb5f461c4e751d5d" name="adf07745d4c21d44ffb5f461c4e751d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf07745d4c21d44ffb5f461c4e751d5d">&#9670;&nbsp;</a></span>decode_utf8_and_len()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static width_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::decode_utf8_and_len </td>
          <td>(</td>
          <td class="paramtype">const data_type *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>data_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Decodes a given input of rle utf8 data to a unicode codepoint and returns the number of bytes it used </p>

</div>
</div>
<a id="a3ba7f5013741d835e165f7cec7bb46ba" name="a3ba7f5013741d835e165f7cec7bb46ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba7f5013741d835e165f7cec7bb46ba">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> is empty</p>
<dl class="section note"><dt>Note</dt><dd>Returns True, if this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> is empty, that also is comparing true with "" </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True, if this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> is empty, false if its length is &gt;0 </dd></dl>

</div>
</div>
<a id="aab61d52e23cc2481787533f78d33ec75" name="aab61d52e23cc2481787533f78d33ec75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab61d52e23cc2481787533f78d33ec75">&#9670;&nbsp;</a></span>encode_utf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static width_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::encode_utf8 </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_type *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Encodes a given codepoint to a character buffer of at least 7 bytes and returns the number of bytes it used </p>

</div>
</div>
<a id="a752a8bc0643ac14d33acc92237b31a90" name="a752a8bc0643ac14d33acc92237b31a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752a8bc0643ac14d33acc92237b31a90">&#9670;&nbsp;</a></span>encode_utf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::encode_utf8 </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_type *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">width_type&#160;</td>
          <td class="paramname"><em>cp_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Encodes a given codepoint (expected to use 'cp_bytes') to a character buffer capable of holding that many bytes. </p>

</div>
</div>
<a id="ac9a514aaf5155df60add7878081063f6" name="ac9a514aaf5155df60add7878081063f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a514aaf5155df60add7878081063f6">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get an iterator to the end of the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>An iterator class pointing to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, that is pointing behind the last codepoint </dd></dl>

</div>
</div>
<a id="a4d939e4c207a1fb58be46cb08ac41bf9" name="a4d939e4c207a1fb58be46cb08ac41bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d939e4c207a1fb58be46cb08ac41bf9">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied character sequence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to compare the end of this string with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a51f778b7103a1937d12a144f8bcbeb5a" name="a51f778b7103a1937d12a144f8bcbeb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f778b7103a1937d12a144f8bcbeb5a">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const data_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied UTF-8 sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a string literal with possibly embedded zeros, interpreted as UTF-8. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="aba76ab340d9b7bd832a8322d883aeb30" name="aba76ab340d9b7bd832a8322d883aeb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba76ab340d9b7bd832a8322d883aeb30">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied character sequence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to compare the end of this string with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="ae330a998e220d8a45c513664cee136e2" name="ae330a998e220d8a45c513664cee136e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae330a998e220d8a45c513664cee136e2">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">const value_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied codepoint sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a string literal with possibly embedded zeros, interpreted as UTF-32. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="ae2896b5c8c7f493f07516fbf4ae52ad4" name="ae2896b5c8c7f493f07516fbf4ae52ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2896b5c8c7f493f07516fbf4ae52ad4">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, data_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied UTF-8 sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated string literal, interpreted as UTF-8. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a94ab0b02ea819b6251982c12641afbac" name="a94ab0b02ea819b6251982c12641afbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ab0b02ea819b6251982c12641afbac">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, value_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied codepoint sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a null-terminated string literal, interpreted as UTF-32. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a56559f9447d8f420060ef5cb622fa08b" name="a56559f9447d8f420060ef5cb622fa08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56559f9447d8f420060ef5cb622fa08b">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::ends_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied codepoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The codepoint to compare the end of this string with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the codepoint 'cp', false otherwise. </dd></dl>

</div>
</div>
<a id="a7a72806433d6c9d573ca797048da7dca" name="a7a72806433d6c9d573ca797048da7dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a72806433d6c9d573ca797048da7dca">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Erases the codepoints inside the supplied range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the first codepoint to be erased </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing to the codepoint behind the last codepoint to be erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the codepoints erased </dd></dl>

</div>
</div>
<a id="aca07ec291edfd06083fd4028df1fcbce" name="aca07ec291edfd06083fd4028df1fcbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca07ec291edfd06083fd4028df1fcbce">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Erases the codepoint at the supplied iterator position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The iterator pointing to the position being erased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the codepoint erased </dd></dl>

</div>
</div>
<a id="a3b54f0b4e746e67176db9f41dd02298c" name="a3b54f0b4e746e67176db9f41dd02298c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b54f0b4e746e67176db9f41dd02298c">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Erases a portion of this string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The codepoint index to start eraseing from </td></tr>
    <tr><td class="paramname">len</td><td>The number of codepoints to be erased from this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied portion erased </dd></dl>

</div>
</div>
<a id="a8a201b18bc25527f26c11edcfaec9777" name="a8a201b18bc25527f26c11edcfaec9777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a201b18bc25527f26c11edcfaec9777">&#9670;&nbsp;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_codepoint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds a specific pattern within the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting at the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint to look for </td></tr>
    <tr><td class="paramname">start_codepoint</td><td>The index of the first codepoint to start looking from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepoint index where and if the pattern was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="ab1caa76a972eb451256aa08ff1c191d2" name="ab1caa76a972eb451256aa08ff1c191d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1caa76a972eb451256aa08ff1c191d2">&#9670;&nbsp;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const data_type *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_codepoint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds a specific pattern within the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting at the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint to look for </td></tr>
    <tr><td class="paramname">start_codepoint</td><td>The index of the first codepoint to start looking from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepoint index where and if the pattern was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="ab4b857cb5f118d17fba9cf28ab2585dc" name="ab4b857cb5f118d17fba9cf28ab2585dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b857cb5f118d17fba9cf28ab2585dc">&#9670;&nbsp;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_codepoint</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds a specific codepoint inside the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting at the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint to look for </td></tr>
    <tr><td class="paramname">start_codepoint</td><td>The index of the first codepoint to start looking from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepoint index where and if the codepoint was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="a33415d47f540922533926394a7b1670d" name="a33415d47f540922533926394a7b1670d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33415d47f540922533926394a7b1670d">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_reference</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a reference to the first codepoint in the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper to the first codepoint in the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </dd></dl>

</div>
</div>
<a id="ac9d2bbad98237f56f838f70399c725ad" name="ac9d2bbad98237f56f838f70399c725ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d2bbad98237f56f838f70399c725ad">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1iterator.html">iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::get </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns an iterator pointing to the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the codepoint to get the iterator to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the specified codepoint index </dd></dl>

</div>
</div>
<a id="a51f0ebf7b5d4b1100f037a9cabf8f7d7" name="a51f0ebf7b5d4b1100f037a9cabf8f7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f0ebf7b5d4b1100f037a9cabf8f7d7">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a copy of the stored allocator</p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the stored allocator instance </dd></dl>

</div>
</div>
<a id="a9b5950f57460a41d511a735cdf98987d" name="a9b5950f57460a41d511a735cdf98987d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5950f57460a41d511a735cdf98987d">&#9670;&nbsp;</a></span>get_codepoint_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static width_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::get_codepoint_bytes </td>
          <td>(</td>
          <td class="paramtype">data_type&#160;</td>
          <td class="paramname"><em>first_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>data_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of code units (bytes) using the supplied first byte of a utf8 codepoint </p>

</div>
</div>
<a id="a8d76d566d0fdaea25c64ed7b316777ee" name="a8d76d566d0fdaea25c64ed7b316777ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d76d566d0fdaea25c64ed7b316777ee">&#9670;&nbsp;</a></span>get_codepoint_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static width_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::get_codepoint_bytes </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of code units (bytes) a codepoint will translate to in utf8 </p>

</div>
</div>
<a id="a034c117f8f5db883c9fbeecf048925bd" name="a034c117f8f5db883c9fbeecf048925bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034c117f8f5db883c9fbeecf048925bd">&#9670;&nbsp;</a></span>get_num_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; V, D, A &gt;::size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::get_num_bytes </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>byte_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>cp_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Counts the number of bytes required to hold the supplied amount of codepoints starting at the supplied byte index (or '0' for the '_from_start' version) </p>

</div>
</div>
<a id="a5cf2ebaa94cce53b5376d652c9ca644c" name="a5cf2ebaa94cce53b5376d652c9ca644c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf2ebaa94cce53b5376d652c9ca644c">&#9670;&nbsp;</a></span>get_num_codepoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; V, D, A &gt;::size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::get_num_codepoints </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>byte_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Counts the number of codepoints that are contained within the supplied range of bytes </p>

</div>
</div>
<a id="a359082cea049a29399a666c525350a7e" name="a359082cea049a29399a666c525350a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359082cea049a29399a666c525350a7e">&#9670;&nbsp;</a></span>get_sso_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::get_sso_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static helper methods. </p>
<p >Get the maximum number of bytes (excluding the trailing '\0') that can be stored within a <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> object </p>

</div>
</div>
<a id="ac029754f9332283b5158f3b963463641" name="ac029754f9332283b5158f3b963463641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029754f9332283b5158f3b963463641">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Inserts a given <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> at the supplied iterator position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator position to insert at </td></tr>
    <tr><td class="paramname">cp</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied codepoint inserted </dd></dl>

</div>
</div>
<a id="ae6c27d7ca4531a7d2174ae8e35a55677" name="ae6c27d7ca4531a7d2174ae8e35a55677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c27d7ca4531a7d2174ae8e35a55677">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Inserts a given codepoint into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> at the supplied iterator position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator position to insert at </td></tr>
    <tr><td class="paramname">cp</td><td>The codepoint to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied codepoint inserted </dd></dl>

</div>
</div>
<a id="aebccd66e4655854a0d9f33b801adb458" name="aebccd66e4655854a0d9f33b801adb458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebccd66e4655854a0d9f33b801adb458">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Inserts a given <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> at the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The codepoint index to insert at </td></tr>
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> inserted </dd></dl>

</div>
</div>
<a id="a4714e8a64d5837fc84052d13f5d069fb" name="a4714e8a64d5837fc84052d13f5d069fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4714e8a64d5837fc84052d13f5d069fb">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Inserts a given codepoint into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> at the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The codepoint index to insert at </td></tr>
    <tr><td class="paramname">cp</td><td>The codepoint to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied codepoint inserted </dd></dl>

</div>
</div>
<a id="a4cbad7e5e7fad26c31b37828ab5098a1" name="a4cbad7e5e7fad26c31b37828ab5098a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbad7e5e7fad26c31b37828ab5098a1">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the number of codepoints in this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Returns the number of codepoints that are taken care of For the number of bytes, </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtiny__utf8_1_1basic__string.html#af1388350a2d5983f12dccd793353d60d">size()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of codepoints (not bytes!) </dd></dl>

</div>
</div>
<a id="a961fe1c91ef8e209b4762f88eca21e5d" name="a961fe1c91ef8e209b4762f88eca21e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961fe1c91ef8e209b4762f88eca21e5d">&#9670;&nbsp;</a></span>lut_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::lut_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Determine, if small string optimization is active </p><dl class="section return"><dt>Returns</dt><dd>True, if the utf8 data is stored within the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> object itself false, otherwise </dd></dl>

</div>
</div>
<a id="abe5310b60c21d2a253d575b8825c73b2" name="abe5310b60c21d2a253d575b8825c73b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5310b60c21d2a253d575b8825c73b2">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_reference</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a reference to the codepoint at the supplied byte position</p>
<dl class="section note"><dt>Note</dt><dd>As this access is raw, that is not looking up for the actual byte position, it is very fast </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The byte position of the codepoint to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper to the codepoint at byte position 'n' </dd></dl>

</div>
</div>
<a id="a0e59b0915326a29c308981afc8a461ca" name="a0e59b0915326a29c308981afc8a461ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e59b0915326a29c308981afc8a461ca">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt;&#160;</td>
          <td class="paramname"><em>summand</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Appends/prepends the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> resp. data_type/value_type (value/literal) to a copy of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, consisting of the concatenated parts. </dd></dl>

</div>
</div>
<a id="a66c3d64ab683835a700ed331d624278c" name="a66c3d64ab683835a700ed331d624278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c3d64ab683835a700ed331d624278c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Move Assignment operator that moves all data out of the supplied and into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Moves all data from 'str' into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> deleting all data that previously was in there The supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> is invalid afterwards and may not be used anymore </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to move from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the string now holding the data (*this) </dd></dl>

</div>
</div>
<a id="aeba1bb0ebaf862bbee1cdfa9a7924328" name="aeba1bb0ebaf862bbee1cdfa9a7924328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba1bb0ebaf862bbee1cdfa9a7924328">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Copy Assignment operator that sets the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to a copy of the supplied one</p>
<dl class="section note"><dt>Note</dt><dd>Assigns a copy of 'str' to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> deleting all data that previously was in there </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the string now holding the data (*this) </dd></dl>

</div>
</div>
<a id="a59f204a4cbed37680fd8489fd48006d2" name="a59f204a4cbed37680fd8489fd48006d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f204a4cbed37680fd8489fd48006d2">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1codepoint__reference.html">reference</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a reference to the codepoint at the supplied index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The codepoint index of the codepoint to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper to the codepoint at position 'n' </dd></dl>

</div>
</div>
<a id="aeb43767f4d21f636d0761fe94a9e305e" name="aeb43767f4d21f636d0761fe94a9e305e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb43767f4d21f636d0761fe94a9e305e">&#9670;&nbsp;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>prependix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Prepend the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prependix</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to be prepended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the supplied string prepended </dd></dl>

</div>
</div>
<a id="afffa9a9bf0ae812f3ffc86460d954360" name="afffa9a9bf0ae812f3ffc86460d954360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffa9a9bf0ae812f3ffc86460d954360">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Appends the supplied codepoint to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint to be appended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the supplied codepoint appended </dd></dl>

</div>
</div>
<a id="a72370d5b61daf6152e4c53fb4c83afee" name="a72370d5b61daf6152e4c53fb4c83afee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72370d5b61daf6152e4c53fb4c83afee">&#9670;&nbsp;</a></span>raw_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1raw__codepoint__reference.html">raw_checked_reference</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>byte_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the codepoint at the supplied byte position</p>
<dl class="section note"><dt>Note</dt><dd>As this access is raw, that is not looking up for the actual byte position, it is very fast. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_index</td><td>The byte position of the codepoint to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepoint at the supplied position </dd></dl>

</div>
</div>
<a id="aa182fcebc6e28df1dc964da45e6d6d50" name="aa182fcebc6e28df1dc964da45e6d6d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa182fcebc6e28df1dc964da45e6d6d50">&#9670;&nbsp;</a></span>raw_erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; V, D, A &gt; &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::raw_erase </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Erases a byte range of this string</p>
<dl class="section note"><dt>Note</dt><dd>As this function is raw, that is without having to compute actual byte indices, it is much faster that <a class="el" href="classtiny__utf8_1_1basic__string.html#aca07ec291edfd06083fd4028df1fcbce">erase()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The byte position index to start erasing from </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to be erased from the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied bytes erased </dd></dl>
<p >Ok, obviously no small string, we have to update the data, the lut and the number of codepoints. BUT: We will keep the lut in the mode it is: inactive stay inactive, active stays active</p>

</div>
</div>
<a id="accaf99e819fac5d4e1d35325753bffba" name="accaf99e819fac5d4e1d35325753bffba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaf99e819fac5d4e1d35325753bffba">&#9670;&nbsp;</a></span>raw_find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_byte</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds a specific pattern within the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting at the supplied byte position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The pattern to look for </td></tr>
    <tr><td class="paramname">start_byte</td><td>The byte position of the first codepoint to start looking from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte position where and if the pattern was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="abd3fb595a3bcebf760c7826aa0675d8a" name="abd3fb595a3bcebf760c7826aa0675d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3fb595a3bcebf760c7826aa0675d8a">&#9670;&nbsp;</a></span>raw_find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_find </td>
          <td>(</td>
          <td class="paramtype">const data_type *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_byte</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds a specific pattern within the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting at the supplied byte position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The pattern to look for </td></tr>
    <tr><td class="paramname">start_byte</td><td>The byte position of the first codepoint to start looking from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte position where and if the pattern was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="a1e860e721e61515e6e88ad7746450cf4" name="a1e860e721e61515e6e88ad7746450cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e860e721e61515e6e88ad7746450cf4">&#9670;&nbsp;</a></span>raw_find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_find </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_byte</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds a specific codepoint inside the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting at the supplied byte position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint to look for </td></tr>
    <tr><td class="paramname">start_byte</td><td>The byte position of the first codepoint to start looking from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte position where and if the codepoint was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="aef267fb9bcfa437525b3e49c9777d381" name="aef267fb9bcfa437525b3e49c9777d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef267fb9bcfa437525b3e49c9777d381">&#9670;&nbsp;</a></span>raw_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_get </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns an iterator pointing to the codepoint at the supplied byte position</p>
<dl class="section note"><dt>Note</dt><dd>As this access is raw, that is not looking up for the actual byte position, it is very fast </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The byte position of the codepoint to get the iterator to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the specified byte position </dd></dl>

</div>
</div>
<a id="a889044fa78c29f198d5d73d78fc8307f" name="a889044fa78c29f198d5d73d78fc8307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889044fa78c29f198d5d73d78fc8307f">&#9670;&nbsp;</a></span>raw_insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Inserts a given <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> at the supplied byte position</p>
<dl class="section note"><dt>Note</dt><dd>As this function is raw, that is without having to compute actual byte indices, it is much faster that <a class="el" href="classtiny__utf8_1_1basic__string.html#a4714e8a64d5837fc84052d13f5d069fb">insert()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The byte position index to insert at </td></tr>
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> inserted </dd></dl>

</div>
</div>
<a id="a6d58aaffce9079d81c6d9d3b0d5eeb87" name="a6d58aaffce9079d81c6d9d3b0d5eeb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d58aaffce9079d81c6d9d3b0d5eeb87">&#9670;&nbsp;</a></span>raw_insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Inserts a given codepoint into this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> at the supplied byte position</p>
<dl class="section note"><dt>Note</dt><dd>As this function is raw, that is without having to compute actual byte indices, it is much faster that <a class="el" href="classtiny__utf8_1_1basic__string.html#a4714e8a64d5837fc84052d13f5d069fb">insert()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The byte position index to insert at </td></tr>
    <tr><td class="paramname">cp</td><td>The codepoint to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, with the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> inserted </dd></dl>

</div>
</div>
<a id="a6f83b377ec12308b3d1ca6c6831080e2" name="a6f83b377ec12308b3d1ca6c6831080e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f83b377ec12308b3d1ca6c6831080e2">&#9670;&nbsp;</a></span>raw_replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; V, D, A &gt; &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::raw_replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>byte_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Replace a number of bytes of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with the contents of the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>As this function is raw, that is not having to compute byte indices, it is much faster than the codepoint-base replace function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_byte</td><td>The byte position at which the replacement is being started </td></tr>
    <tr><td class="paramname">byte_count</td><td>The number of bytes that are being replaced </td></tr>
    <tr><td class="paramname">repl</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to replace all bytes inside the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the replaced part in it </dd></dl>
<p >Ok, obviously no small string, we have to update the data, the lut and the number of codepoints</p>

</div>
</div>
<a id="a7698f8153dba78fd3e6652baf298c58f" name="a7698f8153dba78fd3e6652baf298c58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7698f8153dba78fd3e6652baf298c58f">&#9670;&nbsp;</a></span>raw_rfind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; V, D, A &gt;::size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::raw_rfind </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_byte</em> = <code><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt;&#160;ValueType,&#160;DataType,&#160;Allocator&#160;&gt;::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds the last occourence of a specific codepoint inside the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting backwards at the supplied byte index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint to look for </td></tr>
    <tr><td class="paramname">start_codepoint</td><td>The byte index of the first codepoint to start looking from (backwards) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepoint index where and if the codepoint was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="ad2e81d23dd90dfa7d4c0d4bf1b6458fa" name="ad2e81d23dd90dfa7d4c0d4bf1b6458fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e81d23dd90dfa7d4c0d4bf1b6458fa">&#9670;&nbsp;</a></span>raw_rget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">raw_reverse_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::raw_rget </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a reverse iterator pointing to the codepoint at the supplied byte position</p>
<dl class="section note"><dt>Note</dt><dd>As this access is raw, that is not looking up for the actual byte position, it is very fast </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The byte position of the codepoint to get the reverse iterator to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator pointing to the specified byte position </dd></dl>

</div>
</div>
<a id="a61c369450c5176c9ba41e2bdb86a4843" name="a61c369450c5176c9ba41e2bdb86a4843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c369450c5176c9ba41e2bdb86a4843">&#9670;&nbsp;</a></span>raw_substr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; V, D, A &gt; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::raw_substr </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a portion of the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> (indexed on byte-base)</p>
<dl class="section note"><dt>Note</dt><dd>As this function is raw, that is without having to compute actual byte indices, it is much faster that <a class="el" href="classtiny__utf8_1_1basic__string.html#a21d8d00ba8dff7ad3591f85c85bdee36">substr()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_byte</td><td>The byte position where the substring shall start </td></tr>
    <tr><td class="paramname">byte_count</td><td>The number of bytes that the substring shall have </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> holding the specified bytes </dd></dl>

</div>
</div>
<a id="a12602f878e2feeb4c9592cc5f35bd6b6" name="a12602f878e2feeb4c9592cc5f35bd6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12602f878e2feeb4c9592cc5f35bd6b6">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a reverse iterator to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator class pointing to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, that is exactly to the last codepoint </dd></dl>

</div>
</div>
<a id="ad6bc15a180a4c3028bad7ce9844c41ca" name="ad6bc15a180a4c3028bad7ce9844c41ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bc15a180a4c3028bad7ce9844c41ca">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a reverse iterator to the beginning of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator class pointing to the end of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, that is pointing before the first codepoint </dd></dl>

</div>
</div>
<a id="a168fef38e1e2263fff4f7ac8c0794044" name="a168fef38e1e2263fff4f7ac8c0794044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168fef38e1e2263fff4f7ac8c0794044">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Replace a range of codepoints with the contents of the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the first codepoint to be replaced </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing to the codepoint behind the last codepoint to be replaced </td></tr>
    <tr><td class="paramname">repl</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to replace all codepoints in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the replaced part in it </dd></dl>

</div>
</div>
<a id="a17e304fba808ccb808c6bc2031802c62" name="a17e304fba808ccb808c6bc2031802c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e304fba808ccb808c6bc2031802c62">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Replace a range of codepoints by a number of codepoints</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the first codepoint to be replaced </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing to the codepoint behind the last codepoint to be replaced </td></tr>
    <tr><td class="paramname">repl</td><td>The wide character that will be used to replace the codepoints in the range </td></tr>
    <tr><td class="paramname">n</td><td>(Optional) The number of codepoint that will replace the old ones </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the replaced part in it </dd></dl>

</div>
</div>
<a id="a5dfda37b6b389d441556b3aa83b017ac" name="a5dfda37b6b389d441556b3aa83b017ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfda37b6b389d441556b3aa83b017ac">&#9670;&nbsp;</a></span>replace() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>repl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Replace a number of codepoints of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with the contents of the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The codpoint index at which the replacement is being started </td></tr>
    <tr><td class="paramname">len</td><td>The number of codepoints that are being replaced </td></tr>
    <tr><td class="paramname">repl</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to replace all codepoints in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the replaced part in it </dd></dl>

</div>
</div>
<a id="a7a22682bc767a0524894051b1169e1ad" name="a7a22682bc767a0524894051b1169e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a22682bc767a0524894051b1169e1ad">&#9670;&nbsp;</a></span>replace() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Replace a number of codepoints of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> by a number of other codepoints</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The codpoint index at which the replacement is being started </td></tr>
    <tr><td class="paramname">len</td><td>The number of codepoints that are being replaced </td></tr>
    <tr><td class="paramname">repl</td><td>The wide character that will be used to replace the codepoints </td></tr>
    <tr><td class="paramname">n</td><td>The number of codepoint that will replace the old ones </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the replaced part in it </dd></dl>

</div>
</div>
<a id="aa75346c110d6771e8966859e8331d598" name="aa75346c110d6771e8966859e8331d598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75346c110d6771e8966859e8331d598">&#9670;&nbsp;</a></span>replace() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> &amp; <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Replace a codepoint of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> by a number of codepoints</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The codpoint index to be replaced </td></tr>
    <tr><td class="paramname">repl</td><td>The wide character that will be used to replace the codepoint </td></tr>
    <tr><td class="paramname">n</td><td>The number of codepoint that will be inserted instead of the one residing at position 'index' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>, which now has the replaced part in it </dd></dl>

</div>
</div>
<a id="a3de72049ba4769b1b4e131cc32733de5" name="a3de72049ba4769b1b4e131cc32733de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de72049ba4769b1b4e131cc32733de5">&#9670;&nbsp;</a></span>requires_unicode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::requires_unicode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tinyutf8-specific features </p>
<p >Check whether the data inside this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> cannot be iterated by an std::string</p>
<dl class="section note"><dt>Note</dt><dd>Returns true, if the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> has codepoints that exceed 7 bits to be stored </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True, if there are UTF-8 formatted byte sequences, false, if there are only ascii characters (&lt;128) inside </dd></dl>

</div>
</div>
<a id="a655677e44b35ad5a35d7cf3e33d78f8d" name="a655677e44b35ad5a35d7cf3e33d78f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655677e44b35ad5a35d7cf3e33d78f8d">&#9670;&nbsp;</a></span>rfind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::rfind </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>start_codepoint</em> = <code><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt;&#160;ValueType,&#160;DataType,&#160;Allocator&#160;&gt;::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Finds the last occourence of a specific codepoint inside the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> starting backwards at the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The codepoint to look for </td></tr>
    <tr><td class="paramname">start_codepoint</td><td>The index of the first codepoint to start looking from (backwards) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepoint index where and if the codepoint was found or basic_string::npos </dd></dl>

</div>
</div>
<a id="a1487717f4c6be386e37a6378250f8480" name="a1487717f4c6be386e37a6378250f8480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1487717f4c6be386e37a6378250f8480">&#9670;&nbsp;</a></span>rget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtiny__utf8_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::rget </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a reverse iterator pointing to the supplied codepoint index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The index of the codepoint to get the reverse iterator to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator pointing to the specified codepoint index </dd></dl>

</div>
</div>
<a id="ac402cfbfa983c6e90ba9f48b7fd5c6ac" name="ac402cfbfa983c6e90ba9f48b7fd5c6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac402cfbfa983c6e90ba9f48b7fd5c6ac">&#9670;&nbsp;</a></span>set_non_sso_string_len()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::set_non_sso_string_len </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>string_len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-static helper methods. </p>
<p >Set the main buffer size (also disables <a class="el" href="structtiny__utf8_1_1basic__string_1_1_s_s_o.html">SSO</a>) </p>

</div>
</div>
<a id="a2d77ab002b3c11a55dfc1ea95e7ec28c" name="a2d77ab002b3c11a55dfc1ea95e7ec28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d77ab002b3c11a55dfc1ea95e7ec28c">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename D , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; V, D, A &gt;::shrink_to_fit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Requests the removal of unused capacity. </p>
<p >Determine the threshold above which it's profitable to reallocate (at least 10 bytes and at least a quarter of the memory)</p>
<p >Determine the threshold above which it's profitable to reallocate (at least 10 bytes and at least a quarter of the memory)</p>

</div>
</div>
<a id="af1388350a2d5983f12dccd793353d60d" name="af1388350a2d5983f12dccd793353d60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1388350a2d5983f12dccd793353d60d">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the number of bytes that are used by this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="section note"><dt>Note</dt><dd>Returns the number of bytes required to hold the contained wide string, That is, without counting the trailling '\0' </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes (not codepoints!) </dd></dl>

</div>
</div>
<a id="ad5c4f1252253107d1a681cc4415aca5b" name="ad5c4f1252253107d1a681cc4415aca5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c4f1252253107d1a681cc4415aca5b">&#9670;&nbsp;</a></span>sso_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::sso_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Determine, if small string optimization is active </p><dl class="section return"><dt>Returns</dt><dd>True, if the utf8 data is stored within the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> object itself false, otherwise </dd></dl>

</div>
</div>
<a id="a37bac8bb9521f783d0e81e4bfb1c081b" name="a37bac8bb9521f783d0e81e4bfb1c081b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bac8bb9521f783d0e81e4bfb1c081b">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied character sequence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to compare the end of this string with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a31c146fbc4ef8595c8799b89bae279f8" name="a31c146fbc4ef8595c8799b89bae279f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c146fbc4ef8595c8799b89bae279f8">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const data_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied UTF-8 sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a string literal with possibly embedded zeros, interpreted as UTF-8. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="ae5d96d08341249612aa1ef364e7b12a9" name="ae5d96d08341249612aa1ef364e7b12a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d96d08341249612aa1ef364e7b12a9">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied character sequence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to compare the end of this string with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a2e00fef14f818bc586e670fc3d9d26c9" name="a2e00fef14f818bc586e670fc3d9d26c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e00fef14f818bc586e670fc3d9d26c9">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;size_type LITLEN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">const value_type(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[LITLEN]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied codepoint sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a string literal with possibly embedded zeros, interpreted as UTF-32. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a391ffb15b613c78c9fa781106ab59221" name="a391ffb15b613c78c9fa781106ab59221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391ffb15b613c78c9fa781106ab59221">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, data_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied UTF-8 sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated string literal, interpreted as UTF-8. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a4689d3c69caabe62b1d8b56134def5a9" name="a4689d3c69caabe62b1d8b56134def5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4689d3c69caabe62b1d8b56134def5a9">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enable_if_ptr&lt; T, value_type &gt; *&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied codepoint sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a null-terminated string literal, interpreted as UTF-32. The pointer is expected to be valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the sequence 'str', false otherwise. </dd></dl>

</div>
</div>
<a id="a4b0a15e7617dad786d9f3afe9ca6c3d5" name="a4b0a15e7617dad786d9f3afe9ca6c3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0a15e7617dad786d9f3afe9ca6c3d5">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::starts_with </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>cp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check, whether this string ends with the supplied codepoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The codepoint to compare the end of this string with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if this string ends with the codepoint 'cp', false otherwise. </dd></dl>

</div>
</div>
<a id="a21d8d00ba8dff7ad3591f85c85bdee36" name="a21d8d00ba8dff7ad3591f85c85bdee36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d8d00ba8dff7ad3591f85c85bdee36">&#9670;&nbsp;</a></span>substr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtiny__utf8_1_1iterator.html">raw_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a portion of the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the first codepoint to be included in the substring </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing to the codepoint behind the last codepoint in the substring </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> holding the specified range </dd></dl>

</div>
</div>
<a id="aac0aed33c7a1335c03899f279bbeab25" name="aac0aed33c7a1335c03899f279bbeab25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0aed33c7a1335c03899f279bbeab25">&#9670;&nbsp;</a></span>substr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>len</em> = <code><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt;&#160;ValueType,&#160;DataType,&#160;Allocator&#160;&gt;::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a portion of the <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The codepoint index that should mark the start of the substring </td></tr>
    <tr><td class="paramname">len</td><td>The number codepoints to be included within the substring </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> holding the specified codepoints </dd></dl>

</div>
</div>
<a id="a69a34205d5cf0796596b28c35390c51f" name="a69a34205d5cf0796596b28c35390c51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a34205d5cf0796596b28c35390c51f">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a>&lt; ValueType, DataType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Swaps the contents of this <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> with the supplied one</p>
<dl class="section note"><dt>Note</dt><dd>Swaps all data with the supplied <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The <a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a> to swap contents with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65be8fc22219ec72d04fb2b3b6f3dca1" name="a65be8fc22219ec72d04fb2b3b6f3dca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65be8fc22219ec72d04fb2b3b6f3dca1">&#9670;&nbsp;</a></span>to_wide_literal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename DataType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtiny__utf8_1_1basic__string.html">tiny_utf8::basic_string</a>&lt; ValueType, DataType, Allocator &gt;::to_wide_literal </td>
          <td>(</td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Receive a (null-terminated) wide string literal from this UTF-8 string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A buffer capable of holding at least '<a class="el" href="classtiny__utf8_1_1basic__string.html#a4cbad7e5e7fad26c31b37828ab5098a1">length()</a>+1' elements of type 'value_type' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetiny__utf8.html">tiny_utf8</a></li><li class="navelem"><a class="el" href="classtiny__utf8_1_1basic__string.html">basic_string</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
